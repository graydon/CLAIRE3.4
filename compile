//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| cgen.cl                                                     |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// *******************************************************************
// * Contents                                                        *
// *     Part 1: definition of the C++ code producer                 *
// *     Part 2: utilities for file generation                       *
// *     Part 3: interface declarations                              *
// *     Part 4: use of language dependent patterns (macros)         *
// *     Part 5: System compiling methods                            *
// *******************************************************************

// renaming philosophy:
// keyword => become allcaps and if not good enough, add _CL_
// class => add Claire

// *******************************************************************
// *       Part 1: definition of the C++ code producer               *
// *******************************************************************

// definition of the class
c_producer <: producer(bad_names:list[symbol],        // avoid generating !
                       good_names:list[symbol])       // replacements (same order)


// definition of the instance
C++PRODUCER :: c_producer(
  open_comparators = list(<, >, >=, <=),
  open_operators = list(+,-,*,/,>>),
  extension = ".cpp",
  comment = "C++",
  bad_names = list(
    symbol!("do"), symbol!("if"), symbol!("and"), symbol!("or"),symbol!("not"),
    symbol!("printf"), symbol!("void"), Optimize/Pattern.name,
    symbol!("exception"), symbol!("return"), symbol!("new"),
    symbol!("class"), symbol!("private"), symbol!("operator"),
    symbol!("default"), symbol!("Handle"), symbol!("import"),
    symbol!("catch"), symbol!("stdout"), symbol!("stdin"),
    symbol!("break"), symbol!("char"), symbol!("interface"), symbol!("EOF"),
    symbol!("relation"), symbol!("System"), symbol!("object"),
    symbol!("delete"), symbol!("boolean"), symbol!("function"),
    symbol!("type"), symbol!("system_thing"), symbol!("environment"),
    symbol!("abstract"), symbol!("final"), symbol!("system_object"),
    symbol!("NEW_ALLOC"), symbol!("BAG_UPDATE"), symbol!("SLOT_UPDATE"),
    symbol!("RETURN_ARG"), symbol!("SAFE_RESULT"),symbol!("SAFE_GC"),
    symbol!("collection"),symbol!("error"),symbol!("register"),symbol!("template"),
    symbol!("STRING_UPDATE")),                 // v3.3.36
 good_names = list(
    symbol!("DO"),symbol!("IF"),symbol!("ClaireAnd"),symbol!("ClaireOr"),symbol!("NOT"),
    symbol!("PRINTF"), symbol!("ClaireVoid"), symbol!("ClairePattern"),
    symbol!("ClaireException"), symbol!("RETURN"), symbol!("NEW"),
    symbol!("ClaireClass"), symbol!("PRIVATE"), symbol!("ClaireOperator"),
    symbol!("DEFAULT"), symbol!("ClaireHandle"), symbol!("ClaireImport"),
    symbol!("CATCH"), symbol!("STDOUT"), symbol!("STDIN"),
    symbol!("BREAK"), symbol!("ClaireChar"), symbol!("ClaireInterface"), symbol!("_eof"),
    symbol!("ClaireRelation"),symbol!("Core"),symbol!("ClaireObject"),
    symbol!("_delete"), symbol!("ClaireBoolean"), symbol!("ClaireFunction"),
    symbol!("ClaireType"), symbol!("SystemThing"), symbol!("ClaireEnvironment"),
    symbol!("ABSTRACT"), symbol!("FINAL"),symbol!("SystemObject"),
    symbol!("_NEW_ALLOC"), symbol!("_BAG_UPDATE"), symbol!("_SLOT_UPDATE"),
    symbol!("_RETURN_ARG"), symbol!("_SAFE_RESULT"),symbol!("_SAFE_GC"),
    symbol!("ClaireCollection"),symbol!("ClaireError"),symbol!("ClaireRegister"),
    symbol!("ClaireTemplate"),symbol!("_STRING_UPDATE")),     // v3.3.46
 // a list of interface
 interfaces = list(port, "ClairePort *", string, "char *", char, "ClaireChar *",
                   float, "double ",
                   array, "OID *", function, "OID (*)()"))


// use this producer
(PRODUCER := C++PRODUCER)

// makes an ident (string) from a variable's name
c_string(c:c_producer, self:Variable) : string
 -> (if (compiler.naming = 2) ("v" /+ string!(integer!(self.pname)))
     else (Core/print_in_string(), ident(c,self.pname), Core/end_of_string()))

c_string(c:c_producer, self:symbol) : string
 -> (Core/print_in_string(), ident(c,self), Core/end_of_string())

// to remove
string!(c:c_producer, self:Variable) : string
 -> (if (compiler.naming = 2) ("v" /+ string!(integer!(self.pname)))
     else (Core/print_in_string(), ident(c,self.pname), Core/end_of_string()))

string!(c:c_producer, self:symbol) : string
 -> (Core/print_in_string(), ident(c,self), Core/end_of_string())

// print a symbol for a variable
[ident(c:c_producer,v:Variable) : void
 ->  if (compiler.naming = 2) princ("v" /+ string!(integer!(v.pname)))
     else let s := v.pname, n := get(c.bad_names, s) in
       (if (n = 0) c_princ(string!(s))
        else c_princ@symbol(c.good_names[n])) ]


// print a symbol for the structure definition
[ident(c:c_producer,s:symbol) : void
 -> let n := get(c.bad_names, s) in
       (if (n = 0) c_princ(string!(s))
        else c_princ@symbol(c.good_names[n])) ]


// v3.3.14 - from 2.5 !!!
// a class name is printed with the module identifier
class_princ(c:c_producer,self:class) : void
 -> (if (module!(self.name) != claire)
        (ident(c,(module!(self.name).name)), princ("_")),
     ident(c,self.name))



// code production for basic expression
[produce(c:c_producer,x:any) : void
 -> case x
      (function printf("_function_(~I,~I)", c_princ(x), print(string!(x))),
       char printf("_char_('~I~A')",
                   (if (x % {'"', ''', '?', '\'}) princ("\\")), x),
       environment princ("ClEnv"),
       string  (if OPT.use_string_update printf("copy_string(~S)",x)        // v3.3.46
                else print(x)),                                   // default : much simpler before 3.3.46
       global_variable  globalVar(c,x),
       boolean  (if x princ("CTRUE") else princ("CFALSE")),
       symbol printf("symbol::make(~S,~I,~I)",string!(x),ident(module!(x).name),
                      ident(defined(x).name)),     // v3.2.38 thanks to FXJ
       class (if (x = import) princ("Kernel._cl_import")    // v3.3.22  
              else printf("~I._~I",ident(c,defined(x.name).name),
                             c_princ(string!(x.name)))),
       reserved_keyword printf("~I._cl_~I",ident(c,defined(x.name).name),
                               c_princ(string!(x.name))),
       thing  (if (x % module) printf("~I.it",ident(c,x.name))
               else printf("~I.~I",ident(c,defined(x.name).name),ident(x.name))),
       any princ("CNULL")) ]


// v3.3 : new ! a global variable contains the native value
[globalVar(c:c_producer,x:global_variable) : void
  ->  (if (x.range = {} & x.value % integer) princ(x.value)
       else printf("~I.~I~I", ident(c,defined(x.name).name),
                              ident(x.name),
                              (if not(nativeVar?(x)) princ("->value")))) ]


// we make this a separate method because Java is more difficult
[stat_exp(c:c_producer,self:any,loop:any) : void
  -> if (self % to_C) stat_exp(c, (self as to_C).arg, loop)
     else if (self % to_CL) stat_exp(c, (self as to_CL).arg, loop)
     else if designated?(self)  princ(";")
     else printf("~I;~I", expression(self, loop), breakline()) ]

// *******************************************************************
// *       Part 2: utilities for file generation                     *
// *******************************************************************

// generate a namespace definition (the class)
// this creates the begining of the definition (to be filled)
[namespace!(c:c_producer,m:module) : void
 -> printf("\n\n// namespace class for ~S \n",m),
    printf("class ~IClass: public NameSpace {\npublic:\n",ident(c,m.name)) ]

// ... ends the previous definition and introduces the associated identifier
[module!(c:c_producer,m:module) : void
  -> printf("\n\n// module definition \n"),
     printf(" void metaLoad();};\n\n"),
     printf("extern ~IClass ~I;\n",ident(c,m.name),ident(c,m.name)),
     let m2 := m.part_of in
       while (not(m2.made_of) & m2 != claire)
         (printf("extern NameSpace ~I;\n",ident(c,m2.name)),
          m2 := m2.part_of) ]


[declare(c:c_producer,p:property) : void
 -> breakline(),
    printf("~I = ~A::make(~S,~I~I~I);",expression(p, nil),
           (if (p % operation) "operation" else "property"),
           string!(p.name),
           (if (p.open != 1 | p.mClaire/dispatcher > 0 )               // 1 is the default value for open
               (expression(p.open, {}),princ(","))),
           expression(module!(p.name),nil),
           (if (p % operation) printf(",~A",p.precedence)
            else if (p.mClaire/dispatcher > 0)
               printf(",~I,~A",
                      expression(p.domain,nil),
                      p.mClaire/dispatcher))) ]

// ..
[start_module_interface(c:c_producer, self:module) : void
 -> let %interface:string := (compiler.headers_dir /+ ((*fs* /+ string!(self.name)) /+ ".h")) in
       (OPT.cinterface := fopen(%interface, "w"),         // v3.0.4 -> change directory
        use_as_output(OPT.cinterface),
        printf("// interface defination for module ~S, ~A",self,date!(1)),
        printf("#ifndef CLAIREH_~I\n#define CLAIREH_~I\n", ident(self), ident(self)),
        for x in compiler.headers
           (printf("#include \"~A.h\"\n", x)),
       use_as_output(stdout)) ]

// v3.2.44
[end_module_interface(c:c_producer, self:module) : void -> printf("\n#endif\n")]
    

// ends the module definition and adds a } to each opened class file
[generate_end_file(j:c_producer,m:module) : void
  -> close_block(),       // end of module definition
     fclose(OPT.outfile),
     // print right bracket in the end of each class definition
     for c in {c in OPT.objects | c % class}
       let p := fopen(compiler.source /+ *fs* /+ c_string(j,c.name) /+ j.extension,"a") in
          (use_as_output(p),
           close_block(),
           fclose(p)) ]


// v3.2.44 : make this part dependent on the producer
[generate_classes(j:c_producer, s:string, m:module) : void
 -> printf("\n\n~AClass ~A;\n\n",s,s),
    let m1 := m, m2 := m1.part_of in
       while (not(m2.made_of) & m2 != claire & m2.parts[1] = m1)
         (printf("NameSpace ~I;\n",ident(PRODUCER,m2.name)),
          m2 := m2.part_of, m1 := m2) ]

// MOVE
[generate_start_file(c:c_producer,m:module) : void
  -> //[2] ++++ Creating the file ~A.cpp // c_string(c,m.name),
     start_file(string!(m.name),m),
     OPT.level := 0,
     printf("/* class file for module ~S */",m),
     breakline(),
     breakline(),
     printf("public class ~I extends NameSpace",ident(c,m.name)),
     new_block() ]


[generate_meta_load(c:c_producer,m:module) : void
  -> printf("void ~IClass::metaLoad() ",ident(c,m.name)),
     new_block(),
     breakline(),
     printf("GC_BIND;~IClEnv->module_I = it;\n",breakline()) ]

// start the produced C file
// Put the reference to the claire C header, and some useful comments
[start_file(s:string,m:module) : any
 ->  use_as_output(OPT.outfile),
     printf("/***** CLAIRE Compilation of file ~A.cl \n         [version ~A / safety ~S] ~A *****/\n\n",
            s, release(),compiler.safety,
            substring(date!(1),1,24)),
     printf("#include <claire.h>\n"),
     printf("#include <Kernel.h>\n"),
     for x in Reader/add_modules(list(m))
       (for w in { s in x.uses | s % string}
          printf("#include <~A.h>\n", w),
        if x.made_of printf("#include <~I.h>\n", ident(x.name))),
     if OPT.cfile printf("#include <~A.h>\n", OPT.cfile),
     use_as_output(stdout) ]

// define a new typed variable named v
// v3.0.72  fill with a default value !
[define_variable(c:c_producer,t:class,v:string) : void
  -> printf("~I~A ~I;", interface!(t), v,
              (if (t = integer | t = any) princ("= 0")
               else if (t = float) princ("=0.0"))) ]


[generate_profile(c:c_producer,m:any) : void
 -> if (m % method) get_dependents(m),
    printf("   PRcount *PR_x = PRstart(PRget_property(~I));~I",
             expression( (case m (method m.selector, any fastcall)), nil),
             breakline())  ]

// this part depends on the target language   -  v3.2.44
[generate_interface(c:c_producer,self:module) : void
 -> for x in list{x in OPT.objects | x % class}     // avoid problems with forward !
       printf("\nclass ~I;", class_princ(c,x)),  // v3.3.14
    // generate the list of the class structures
    for x in list{x in OPT.objects | x % class }     // prints the class definitions
       printf("\n\nclass ~I: public ~I~Ipublic:~I~I~I;", class_princ(c,x),    // v3.3.14
               class_princ(c,x.superclass),                                   // v3.3.14
               (new_block(), breakline()),
               (for y:slot in {s in get_indexed(x) |       // v3.2 take care of overriding
                               forall(s2 in x.superclass.slots | s2.selector != s.selector)}
                 (breakline(),
                  princ("   "),
                  interface!(PRODUCER,psort(y.range)),
                  ident(y.selector.name),
                  princ(";"))),
               methods_interface(PRODUCER,x),
               close_block()),
     for l in OPT.functions     // prints the API methods
       let %f := l[1], %vars := l[2], s := l[3] in
         printf("\nextern ~I ~I(~I);", interface!(PRODUCER,s), c_princ(%f),
                typed_args_list(%vars)) ]


// new in v3.3
// produce a native global variable for sorts integer, float and object
// the form is  module.name = value
[global_var_def!(c:c_producer,self:module, x:Let) : void
  -> let %gvar := get(x.value.args[1] as symbol) as global_variable,
         s := getRange(%gvar),
         %update := (x.arg as Do).args[2],  // should be an Update but may be a call ? .. v3.3.04
         %upval := (case %update (Update %update.value,    // Update is easy
                                  (Call U Call_method) %update.args[5],    // v3.3.04/0.08- a bug found by E. Gaudin & FXJ
                                  any error("Design bug: make ~S a public global var !",%gvar))), // hopefully, will never be used
         b:boolean := c_func(%upval),
         varg := build_Variable("V_C", any) in
       (if not(nativeVar?(%gvar)) statement(x,nil,nil)                   // storeable GV use old code pattern ...
        else (if not(b)
              printf("~IOID ~I;~I~I",new_block(),
                               ident(c,varg),
                               breakline(),
                               statement(%upval,c_string(PRODUCER,varg),nil)),
               printf("~I.~I = ~I;~I",
                           ident(c,self.name),
                           ident(c,%gvar.name),
                           (if b to_c(c,%upval,s,nil)
                            else to_c(c,varg, s,nil)),
                           (if not(b) close_block(), breakline())))) ]
       



// ----------- auxiliairy functions for function generation ------------------------


 // prints the GC initial statement
[gc_introduction(c:c_producer,%b:any) : void
 -> if OPT.protection
       let z := gc_usage(%b,false) in
         (// [DEBUG] gc_usage -> ~S // z,
          if (OPT.loop_gc & z % integer)
            (if (z < 100)
                (OPT.loop_index := 0,   // single index
                 printf("GC_RESERVE(1);  // HOHO v3.0.55 optim !"))
             else printf("GC_RESERVE(~A);  // v3.0.55 optim !", OPT.loop_index + 1))
          else printf("GC_BIND;"),
          // note: we could try to remove useless GC_BIND but it requires to modify the way
          // %end is computed (through protect_result) early in the print_c_function method
          breakline()) ]


// a new method (v3.0.55) that returns an abstraction of the gc protection usage:
//    false: does not use to_protect
//    true:  use protection but not on variables within a loop
//    <int>: use protection, but only once on a variable within a loop (i is the index)*
//    1000:  use protection fully
[gc_usage(self:any,loop:boolean) : any
 -> case self
      (Instruction case self
            (Construct gc_usage*(self.args,loop),
             Definition true,
             Call_method gc_usage*(self.args,loop),
             Call_slot gc_usage(self.arg,loop),
             Call_table gc_usage(self.arg,loop),
             Call_array gc_usage(self.arg,loop),
             to_C  gc_usage(self.arg,loop),
             to_CL  gc_usage(self.arg,loop),   // v3.2.42
             to_protect true,
             Update gc_usage(self.value,loop),
             Call gc_usage*(self.args,loop),
             If gc_or(gc_usage(self.test,loop),
                      gc_or(gc_usage(get(arg, self), loop),
                            gc_usage(get(other, self), loop))),
             Do gc_usage*(self.args,loop),
             Iteration gc_or(gc_usage(self.set_arg,loop), gc_usage(self.arg,true)),
             Let let x := get(value,self) in
                      gc_or((if (loop & x % to_protect) self.var.index else false),
                            gc_or(gc_usage(x,loop),
                                  gc_usage(self.arg, loop))),
             Assign let x := get(arg,self) in
                      gc_or((if (loop & inner2outer?(x)) self.var.index   // v3.3.26 !
                             else false),
                            gc_usage(x,loop)),
             to_protect true,
             Gassign  gc_usage(self.arg,loop),
             And gc_usage*(self.args,loop),
             Or gc_usage*(self.args,loop),
             Cast gc_usage(self.arg, loop),
             Super gc_usage*(self.args,loop),
             Case gc_usage*(self.args,loop),
             While gc_or(gc_usage(self.arg, true), gc_usage(self.test, loop)),
             Return gc_usage(self.arg, loop),
             Handle gc_or(gc_usage(self.arg, loop), gc_usage(self.other, loop)),
                    //        gc_usage(self.test, loop)  v3.4 : the test does not matter, it's a class !
             any false),
       any false) ]


// combining abstract values
[gc_or(x:any,y:any) : any
  -> if (x = false) y
     else if (x = true) (if (y = false) x else y)
     else if (y % integer) (if (x = y) y else 1000)
     else x]

// apply gc_usage to a list
[gc_usage*(l:list,loop:boolean) : any
  -> let x:any := false in
         (for y in l x := gc_or(x,gc_usage(y,loop)), x) ]

       
// produce the debugging code introduction
[debug_intro(c:c_producer,self:lambda,x:method) : void
 -> let m := (case x (method x.module!)),
        n := 1 in
       printf("DB_BIND(~I,~I,~A,{~I});~I", ident(m),
              expression(x.selector, {}), length(self.vars),
              (if (length(self.vars) = 1 & (self.vars[1]).range = void)
                  printf("PUSH(_oid_(ClEnv));")
              else (for v in self.vars
                      (printf("PUSH(~I);",
                         (let s := x.srange[n] in
                            (if ((s = any & v.range != float) | s = integer) // v3.3.28
                                expression(v, false)
                             else to_cl(c, v, (if (v.range = float) float else s), false)))),
                       n :+ 1))),
               breakline()) ]
                  

// produce the end statement for the function. self tells if the result
// is needed.
// we also add the debugging unbind if needed.
[protect_result(c:c_producer,s:class,use_gc:boolean,x:any) : string
 -> if (compiler.safety > 5)
       (OPT.protection := false, use_gc := false, OPT.loop_gc := false),
    let s1 := (if (s != void)
                 (if use_gc "GC_UNBIND; return " else "return ")
                  else if use_gc "GC_UNBIND;"
                  else ""),
         m := (if need_debug?(x) (x as method).module!) in
       case m
        (module (Core/print_in_string(),
                 printf("DB_UNBIND(~I,~I,~I);~I  ~A", ident(m),
                        expression(x.selector, {}),
                        (if (s = void) princ("CNULL")
                         else if (s = any | s = integer) princ("Result")
                         else to_cl(c,build_Variable("Result", s), s, nil)),
                        breakline(),
                        s1),
                 Core/end_of_string()),
         any (if (OPT.profile? & (x % method | x = unknown)) "PRend(PR_x);" /+ s1
              else s1)) ]

// how to declare a function in the interface file and its header in the
// output file
[generate_function_start(c:c_producer,self:lambda,s:class,m:any, %nom:string) : void
 ->  let %dom := (if self.vars self.vars[1].range else any),
         %f := make_function(%nom),
         lv := (if (length(self.vars) = 1 & %dom % {void, environment})  nil       // v3.0.05 was : & not(s = float)
                else self.vars) in
       (update_function_entry(c,%f,lv,s),  // OPT.functions :add list(%f, lv, s),        // register the function in the API list
        use_as_output(OPT.outfile),
        case m (method (if (m.range = float | float % m.domain)                ; <FXJ>: PATCH !
                           generate_float_function(c,m,string!(%f))
                        else if (m.range % tuple)
                           generate_tuple_function(c,m,string!(%f)))),
        generate_regular_function(c,self,%f,s,m,lv)) ]


// regular case
[generate_regular_function(c:c_producer,self:lambda,%f:function,s:class,m:any,lv:list) : void
  -> if (compiler.naming != 2)
       printf("\n/* The c++ function for: ~I */\n",
               (case m
                 (method printf("~S(~I) [~I]", m.selector,
                                Language/ppvariable(self.vars),
                               (if (compiler.naming = 1) bitvectorSum(status!(m)))),
                  any princ(string!(%f))))),
     printf("~I ~I(~I)\n", interface!(c,s), c_princ(%f), typed_args_list(lv)) ]


// new: make a special signature function (float -> OID) for methods that use
// float in their signature
[generate_float_function(c:c_producer,m:method,%nom:string) : void
 -> let ld := (if (length(m.domain) = 1 & domain!(m) = void) nil else m.domain),
        n := length(ld),
        lv := list{Variable(pname = gensym(),
                            range = (if (x = float) any else x)) | x in ld},
        %nom_ := %nom /+ "_",
        %f := make_function(%nom_),
        %lambda := lambda!(lv,nil),
        s := (if (m.range = float) any else psort(m.range)) in
       (generate_regular_function(c,%lambda, %f, s, m,lv),
        OPT.functions :add list(%f, lv, s),
        new_block(),
        if (s != void) printf("return "),
        if (m.range = float) printf("_float_("),
        printf("~I(~I)",c_princ(functional!(m)),
                (for i in (1 .. n)
                  (if (i != 1) princ(","),
                   if (m.domain[i] = float) printf("float_v(~I)",expression(lv[i],nil))
                   else expression(lv[i],nil)))),
        if (m.range = float) printf(")"),
        princ(";"),
        close_block(),
        princ("\n")) ]

[at(c:c_producer) : void -> princ("->")]

// v3.2.52 : generate a nice function that can be used by the interpreter for tuple-valued
// methods. Note that this could be used instead of adding an ->coyIfNeeded
[generate_tuple_function(c:c_producer,m:method,%nom:string) : void
 -> let ld := (if (length(m.domain) = 1 & domain!(m) = void) nil else m.domain),
        n := length(ld),
        lv := list{Variable(pname = gensym(), range = x) | x in ld},
        %nom_ := %nom /+ "_",
        %f := make_function(%nom_),
        %lambda := lambda!(lv,nil),
        s := tuple in
       (generate_regular_function(c,%lambda, %f, s, m,lv),
        OPT.functions :add list(%f, lv, s),
        new_block(),
        if (s != void) printf("return "),
        printf("~I(~I)",c_princ(functional!(m)),
                (for i in (1 .. n)
                  (if (i != 1) princ(","),
                   expression(lv[i],nil)))),
        printf("->copyIfNeeded()"),
        princ(";"),
        close_block(),
        princ("\n")) ]


// management of OPT.functions: list of entries ->  function info =
// list(%function, lv, s, m, lambda, outfile)     [mode f2c]
// list(%function, lv, s)                         [mode f2f]
[create_function_entry(c:c_producer, lb:lambda, %f:string, m:any) : any  -> nil ]
[update_function_entry(c:c_producer, %f:function, lv:list, s:class) : any
  ->  OPT.functions :add list(%f, lv, s), false ]

    
// *******************************************************************
// *       Part 3: interface declarations                            *
// *******************************************************************

// use the interface list
[c_interface(self:class) : string
 -> let n := get(PRODUCER.interfaces, self) in
       (if (n = 0) "OID *" else PRODUCER.interfaces[n + 1] as string ) ]

[c_interface(self:class,s:string) : void
 -> let n := get(PRODUCER.interfaces, self) in
       (if (n = 0) PRODUCER.interfaces := (PRODUCER.interfaces add self) add s
        else PRODUCER.interfaces[n + 1] := s) ]

// useful and nice
[c_interface(self:method) : void
 -> c_princ(Optimize/function_name(self.selector, self.domain,self.functional)) ]


// How to declare a sort in C. The boolean tells if we are in an external
// mode , in which case we produce the C sort. Otherwise, we use OIDs.
// we shall add later: float and boolean
[interface!(c:c_producer, self:class) : void
 ->  if (self = void) princ("void ")
     else if (self = integer) princ("int ")
     else if (self % {char,boolean,function}) printf("~I *", ident(c,self.name))
     else if (self inherit? import | self = string | self = array)
        princ(c_interface(self))
     else if (self inherit? object) printf("~I *", class_princ(c,self))  // v3.3.14
     else if (self inherit? bag) printf("~I *", ident(c,self.name))
     else if (self = float) printf("double ")
     else princ("OID ") ]

// general translation method: oself is an expression that must be translated
// to a CLAIRE id. oself is functional !
[to_cl(c:c_producer,x:any,s:class,loop:any) : void
 -> if (s = void) printf("_void_(~I)", expression(x, loop))
    else if (s inherit? object)
       (if (x = true) printf("Kernel.ctrue")
        else if (x = false) printf("Kernel.cfalse")
        else printf("_oid_(~I)", expression(x, loop)))
    else if (s = integer)
        (if (compiler.safety > 1) expression(x, loop)
         else printf("_integer_(~I)", expression(x, loop)))
    else if (s = char) printf("_oid_(~I)", expression(x, loop))
    else if (s = string) printf("_string_(~I)",expression(x,loop))
    else if (s = array) printf("_array_(~I)",expression(x,loop))
    else if (s = float) printf("_float_(~I)",expression(x,loop))
    else if (s inherit? import)
        printf("ClAlloc->import(~I,(int *) ~I)", expression(s, {}),
                                         expression(x, loop))
    else if (s = any) expression(x, loop)
    else error("[internal] to_cl for a ~S is not implemented", s) ]

// reverse function
//
[to_c(c:c_producer,x:any,s:class,loop:any) : void
  -> if (s = integer) expression(x, loop)
     else if (x = unknown) printf("NULL")
     else if (x % global_variable & x.range = {} & x.value = nil)
        printf("Kernel.nil")
     else printf("~I~I)", to_c(c,s), expression(x, loop)) ]

// produces the first half of the previous statement
[to_c(c:c_producer,s:class) : void
 -> if (s inherit? object) printf("OBJECT(~I,", class_princ(s))   // v3.3.14
    else if (s = float) princ("float_v(")
    else if (s = char) printf("char_v(")
    else if (s = string) printf("string_v(")
    else if (s = array) printf("array_v(")
    else if (s inherit? import) printf("EXPORT((~I),", interface!(s))
    else error("[internal] to_c for a ~S is not implemented", s) ]

[public_static(c:c_producer) : void -> nil]

// v3.1.12
[bool_exp!(c:c_producer,self:any,loop:any)  : void
  -> case self
       (to_CL printf("(~I ? Kernel.ctrue : Kernel.cfalse)", bool_exp(self,true,loop)),
        any printf("(~I ? CTRUE : CFALSE)", bool_exp(self,true,loop))) ]


// *******************************************************************
// *       Part 4: use of language dependent patterns (macros)       *
// *******************************************************************

[inherit_exp(c:c_producer,a1:any,a2:any,loop:any) : void
 -> printf("INHERIT(~I,~I)", expression(a1, loop), expression(a2, loop)) ]

[bitvector_exp(c:c_producer,a1:any,a2:any,loop:any) : void
 -> printf("BCONTAIN(~I,~I)", expression(a1, loop), expression(a2, loop)) ]

// when we print an equality, we do not need to_CL !
[equal_exp(c:c_producer, a1:any,pos?:boolean,a2:any,id?:any) : void
 -> if (a1 % Compile/to_CL & a2 % Compile/to_CL &
         osort(a1.set_arg) = osort(a2.set_arg) &
         (Compile/identifiable?(a1.arg) |              // NEW:make sure id? := true or string
          Compile/identifiable?(a2.arg) |
          a1.set_arg = string | a1.set_arg = float))   // or float => will generate nice form
       equal_exp(c,a1.arg, pos?, a2.arg, true)
     else if (a1 % to_protect & a1.arg % to_CL & not(c_gc?(a1.arg.arg)) & 
              a2 % to_protect & a2.arg % to_CL & not(c_gc?(a2.arg.arg))) 
          equal_exp(c,a1.arg,pos?,a2.arg,id?)   // v3.3.32: gc-protect because of to_cl -> remove them
     else if (c_sort(a1) = string & c_sort(a2) = string &
              not(case a2 (to_C (a2.arg = unknown))))
        printf("(equal_string(~I,~I) ~I CTRUE)",
               expression(a1, nil), expression(a2, nil), sign_equal(pos?))
     else if (a1 % Compile/to_CL & a1.set_arg != integer & a2 = unknown)
       printf("(~I ~I NULL)", expression(a1.arg, nil), sign_equal(pos?))
     else if (char_exp?(c,a1) | char_exp?(c,a2))
        printf("(~I ~I ~I)", char_exp(c,a1, nil), sign_equal(pos?),
               char_exp(c,a2, nil))
     else if (id? | Compile/identifiable?(a1) | Compile/identifiable?(a2) |
              c_sort(a1) = float)
        (// if sort(a1) != sort(a2) y'a bug
         if (stupid_t(a1) glb stupid_t(a2) = {})
            (warn(), trace(2,"~S = ~S will fail ! [263]",a1,a2)),
         printf("(~I ~I ~I)", bexpression(a1, nil), sign_equal(pos?),
                bexpression(a2, nil)))
     
    else printf("(equal(~I,~I) ~I CTRUE)",
                 expression(a1, nil),
                 expression(a2, nil), sign_equal(pos?)) ]

// new: special code for char
[char_exp?(c:c_producer,x:any) : boolean
  -> case x (char true,
             Call_method let m := x.arg in
                           (m = *nth_1_string* |
                            (m = *nth_string* & compiler.safety >= 2)),
             any false) ]

[char_exp(c:c_producer,x:any,loop:any) : void
  -> case x (char printf("'~I~A'",
                   (if (x % {'"', ''', '?', '\'}) princ("\\")), x),
             Call_method
                let m := x.arg in
                   (if  (m = *nth_1_string* | m = *nth_string*)
                      let a1 := x.args[1], a2 := x.args[2] in
                         printf("~I[~I - 1]", expression(a1, loop),
                                              expression(a2, loop))
                    else printf("((char) ~I->ascii)",expression(x,loop))),
             any printf("((char) ~I->ascii)",expression(x,loop))) ]

             
// reads the member x from an expression oself of owner s
[c_member(c:c_producer,self:any,s:class,x:property,loop:any) : void
 ->  if (stupid_t(self) inherit? s)
        printf("~I->~I", expression(self, loop), ident(x.name))
     else printf("CLREAD(~I,~I,~I)", class_princ(s),
                 expression(self, loop), ident(x.name)) ]

[addFast(c:c_producer) : void -> printf("->addFast") ]

// produces a cast for C++
cast!(c:c_producer,self:C_cast,loop:any) : void
 -> printf("((~I *) ~I)", class_princ(self.set_arg),    // v3.3.14
                          expression(self.arg, loop))

// u is either an expression, a variable or a string, which is indicated by the
// value of kind
// we use a place reserved in the stack (note the optimization if OPT.loop_index = 0)
// v3.2.32: trap the integer case ...
[gc_protection_exp(c:c_producer,v:Variable,exp?:boolean,u:any,loop:any) : void
  -> c.stat :+ 1,          // v3.3.32
     if (osort(v.range) = float | osort(v.range) = integer)     // in v3.0 double are NOT protected !
        printf("(~I=~I)",ident(c,v),             // v3.0.72
               (if exp? expression(u,loop) else c_princ(u as string)))
     else printf("GC__~A(~I~I, ~A)",
       (if (osort(v.range) = any) "OID"
        else if (osort(v.range) = string) "STRING"
        else "ANY"),        // any is for object
       ident(c,v),
       (if (u != v)         // used for an assinment
         (princ(" = "),
          (if exp? expression(u,loop) else c_princ(u as string)))),
       (if (OPT.loop_index = 0) 1 else v.index + 1)) ]   // v3.0.55

// generic for bags
[bag_expression(cx:c_producer,c:class,l:bag,t:type,loop:any) : void
  -> if (length(l) = 0)
        printf("~S::empty(~I)",c,
               (if (t != void)
                    (//[5] t = ~S => ~S // t, c_code(t,object),
                     expression(c_code(t,object),loop))))
     else (printf("~S::alloc~I(~I~A,~I)", c,
                  (if (c = tuple & OPT.alloc_stack) princ("Stack")),                 // v3.2.26
                  (if (t != void) printf("~I,",expression(c_code(t,object),loop))),
                  length(l),
                  args_list(l, loop, length(l) > 2))) ]



// *******************************************************************
// *       Part 5: System compiling methods                          *
// *******************************************************************


// compiles a list of modules into a system file, which is the small definition
// of the module and the associated load function
// v3.2.54 add the m argument
[generate_s_file(self:string,l:list,m:any) : void
 -> let p := fopen((compiler.source / self) /+ "-s" /+ PRODUCER.extension, "w"),
        l_used:list := Reader/add_modules(l),
        l_necessary:list := parents(l) in
       (OPT.cinterface := p,
        OPT.properties := set<property>(),
        OPT.objects := list<any>(),
        OPT.functions := list<any>(),
        OPT.need_to_close := set<any>(),
        OPT.legal_modules := set!(l_necessary),
        use_as_output(p),
        printf("// --- System configuration file for ~S , [~S] ---\n\n",
               self, date!(1)),
        printf("#include <claire.h>\n"),
        printf("#include <Kernel.h>\n"),
        for x in l_used
          (if x.made_of printf("#include <~I.h>\n", ident(x.name))),
        create_load_modules(self, p, l_necessary,m),
        if (main @ list & domain!(main @ list) = list)
         let s := "main_list" in // if (compiler.naming = 0) "claire_main_list" else "main_list") in
          (printf("\nextern void ~A(list *l);\n",s),
           printf("void call_main() {~A(ClEnv->params);}\n",s))
        else princ("\nvoid call_main() {default_main();}\n"),     // v3.2.50 use default_main ...
        fclose(p)) ]

// called by the run_system function. The goal of this method is
// to create the modules, and fill the corresponding indexed of the
// "system" object.
[create_load_modules(self:string,p:port,l_necessary:list,m:any) : void
 -> breakline(),
    for x in {m in l_necessary | m.status = 5}
       printf("void load_~I() {~I.metaLoad();}\n",ident(x.name), ident(x.name)),
    printf("\n\nvoid loadModules() \n"),
    new_block(),
    printf("//module definitions ~I", breakline()),
    for x in (l_necessary \ {claire,mClaire,Kernel})
       printf("~I.initModule(~S,~I,~I,~I~S,~I);~I", ident(x.name), string!(x.name),
              expression(x.part_of,nil),
              expression(c_code(x.uses,list),nil),
              breakline(),
              source(x),
              expression(c_code(x.made_of,list),nil),
              breakline()),
    printf("//module load ~I", breakline()),
    for x in {m in l_necessary | m.made_of & m.status != 5}
       printf("~I.metaLoad();~I",ident(x.name),breakline()),
    for x in {m in l_necessary |m.status = 5}
      ( printf("~I.it->evaluate = ~I~I",ident(x.name),
               expression(make_function("load_" /+ string!(x.name)), false),
               breakline()),
        printf("~I.it->status = 2;~I",ident(x.name), breakline())),
    printf("ClEnv->module_I = ~I; ~I",
            expression( (if (m % module) m else claire), nil),
            breakline()),
    if (compiler.safety > 5) printf("ClAlloc->statusGC = 2;\n"),  // v3.1.12
    if OPT.profile?
       for p in Kernel/graph(Reader/PRdependent)
         case p (property for p2 in Reader/PRdependent[p]
                     (if (not(p2 % OPT.to_remove) &
                           mClaire/definition(p.name) = mClaire/definition(p2.name))   // v3.2.58
                     printf("PRdepends_property(~I,~I);\n",expression(p,nil),
                                 expression(p2,nil)))),
    close_block() ]

// new: add the code to define interface methods
// WARNING: the interface methods are uniform but C++ does not support
// dynamic dispatch on them - they are really meant to be interface
// methods
methods_interface(c:c_producer,x:class) : void
  -> (for p in Language/InterfaceList[x]
       let m := (p @ x) in
         (//[5] method interface ~S at ~S -> ~S // p,x,m,
          if (m % method & known?(formula,m))
            let s := class!(m.range), %vars := cdr(m.formula.vars) in
               printf("~I~I ~I(~I);  ",
                      breakline(),
                      interface!(c,s),
                      c_princ(p.name),
                      typed_args_list(%vars))))

methods_bodies(c:c_producer,x:class) : void
  -> (for p in Language/InterfaceList[x]
       let m := (p @ x) in
         (//[5] write method body ~S at ~S -> ~S // p,x,m,
          if (m % method & known?(formula,m))
            let s := class!(m.range), %vars := cdr(m.formula.vars) in
              (printf("~I// interface method ~I", breakline(), breakline()),
               printf("~I~I ~I::~I(~I)~I  ",
                      breakline(),
                      interface!(c,s),
                      class_princ(x),  // v3.3.14
                      c_princ(p.name),
                      typed_args_list(%vars),
                      breakline()),
               printf("\t{ ~I~I;}\n~I",
                      (if (s != void) printf("return (~I) ",interface!(c,s))),
                      (if (p.mClaire/dispatcher > 0)
                          printf("~I->fcall((int) this~I)",
                                 expression(p,nil),
                                 (for v in %vars
                                     (princ(",(int) "), expression(v,nil))))
                       else printf("~I(this~I)",
                                c_princ(Compile/functional!(m)),
                                (for v in %vars
                                     (princ(","), expression(v,nil))))),
                       breakline()))))



//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| copt.cl,                                                    |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file core.cl: about()                 |
//+-------------------------------------------------------------+

// *******************************************************************
// * Contents                                                        *
// *     Part 1: the inline coding of function calls                 *
// *     Part 2: Fast dispatch (inlining method selection)           *
// *     Part 3: Specific code for expressions                       *
// *     Part 4: Specific code for control structures                *
// *******************************************************************


// *******************************************************************
// *       Part 1: the inline coding of function calls               *
// *******************************************************************

// these methods are important since they contain the open-coding
// optimisations. Some of the method calls may be replaced
// directly by C expressions.
// functions with one argument
[inline_exp(c:c_producer,self:Call_method1,loop:any) : void
 -> let m := self.arg, p := m.selector, a1 := car(self.args) in
       (if (p = - & (domain!(m) = integer | domain!(m) = float))
           printf("(-~I)", bexpression(a1, loop))
        else if (p = owner & Compile/designated?(a1))
           printf("OWNER(~I)", expression(a1, loop))
        else if (p = sqrt & domain!(m) = float)
           printf("sqrt(~I)", expression(a1, loop))
        else if (p = eval & Compile/designated?(a1))
           printf("OPT_EVAL(~I)", expression(a1, loop))
        else if (p = externC) princ(a1)
        else if (m = *length_bag* & Compile/designated?(a1))
           printf("~I->length", expression(a1, loop))
        else if (p = integer! & domain!(m) = char & Compile/designated?(a1))
           printf("~I->ascii", expression(a1, loop))
        else if (m = *length_array*)
           printf("~I[0]", expression(a1, loop))
        else if (m = *not* & c_type(a1) <= boolean)     // v3.2.24 for Ali :-)
           printf("((~I == Kernel.ctrue) ? CFALSE : CTRUE)", expression(a1, loop))
        // v3.3.12 - change suggested by Sylvain
        else print_external_call(c, self, loop)) ]

// functions with two arguments
//
[inline_exp(c:c_producer,self:Call_method2,loop:any) : void
 -> let m := self.arg, p := m.selector, a1 := self.args[1], a2 := self.args[2] in
      ( if (m = *min_integer* & Compile/designated?(a1) &
                 Compile/designated?(a2))
           printf("((~I <= ~I) ? ~I : ~I)",
                  expression(a1, loop), expression(a2, loop),
                  expression(a1, loop), expression(a2, loop))
        else if (m = *max_integer* & Compile/designated?(a1) &
                 Compile/designated?(a2))
           printf("((~I <= ~I) ? ~I : ~I)",
                  expression(a1, loop), expression(a2, loop),
                  expression(a2, loop), expression(a1, loop))
        else if (p = class! & a1 % symbol)
           printf("(~I._~I = ClaireClass::make(~S,~I,~I.it))", ident(defined(a1)),
                  c_princ(string!(a1)), // protected by _
                  string!(a1),
                  expression(a2, loop),
                  ident(module!(a1)))    // <yc>  7/98  safer (was current_module)
        else if (p % c.open_operators &
                 (p != / | compiler.safety >= 5) &
                 (m.domain[1] = m.domain[2]) &               // v3.1.08
                 (c_type(a1) <= integer | c_type(a1) <= float))
           printf("~I(~I~A~I)",
                  (if (compiler.safety < 2 & c_type(a1) <= integer) princ("_integer_")),
                  bexpression(a1, loop),        // v3.2.06
                  string!(p.name),
                  bexpression(a2, loop))
        else if (m = *contain* & Compile/identifiable?(a2))
           printf("~I->memq(~I)", expression(a1, loop), expression(a2, loop))
        else if ((m = *nth_list* & compiler.safety >= 2) | m = *nth_1_bag*)
           printf("(*(~I))[~I]", expression(a1, loop),
                  expression(a2, loop))
        else if (p = add! & domain!(m) <= bag)
           printf("~I->addFast(~I)", expression(a1, loop), expression(a2, loop))
        else if (m = *nth_string* & compiler.safety >= 2)
           printf("_char_(~I[~I - 1])", expression(a1, loop), expression(a2, loop))
        else if (m.selector = identical?)
           printf("(~I ? CTRUE : CFALSE)",
                  bool_exp(self, true, loop))
        else if (m.selector = externC) princ(a1)
        else if (p = inlineok? & a2 % string)
           printf("~I->inlineDef(~S)",expression(a1,loop),a2)
        else print_external_call(c, self, loop)) ]

// functions with three arguments or more
[inline_exp(c:c_producer,self:Call_method,loop:any) : void
 -> let m := self.arg, b := OPT.Compile/alloc_stack,
         a1 := self.args[1], a2 := self.args[2], a3 := self.args[3] in
       (OPT.Compile/alloc_stack := false,
        if (m = *nth=_list* & compiler.safety >= 3)
           printf("((*(~I))[~I]=~I)", expression(a1, loop),
                  expression(a2, loop), expression(a3, loop))
         else if (domain!(m) = string & ((m.selector = nth= & compiler.safety >= 2) |
                                         m.selector = nth_put))
           printf("(~I[~I - 1] = (char) ~I->ascii)", expression(a1, loop),
                  expression(a2, loop),
                  expression(a3, loop))
         else if (m = *nth_1_string*)
           printf("_char_(~I[~I - 1])", expression(a1, loop), expression(a2, loop))
         else if (m.selector = store & c_type(a1) <= list &
                 ((length(self.args) = 4 & self.args[4] = true) | length(self.args) = 3))
           printf("STOREI((*~I)[~I],~I)",
                   expression(a1, loop),
                   expression(a2, loop),
                   expression(a3, loop))
         else if (m.selector = store & c_type(a1) <= array &
                  member(c_type(a1)) ^ float = {} &
                 ((length(self.args) = 4 & self.args[4] = true) | length(self.args) = 3))
           printf("STOREI(~I[~I],~I)",
                        expression(a1, loop),
                        expression(a2, loop),
                        expression(a3, loop))
        else if (m.selector = add_slot & getC(a1) % class)
           printf("CL_ADD_SLOT(~I,~I,~I,~I,~I,~I)",expression(a1, loop),
                        class_princ(getC(a1)), // v3.3.14
                        expression(a2, loop),
                        ident(getC(a2).name),  
                        expression(getC(a3), loop),
                        expression(self.args[4],loop))
        else if (m.selector = add_method)
         (if (a1 % property)
          printf("~I->add~IMethod(~I,~I,~I	~I,~I)",expression(a1, loop),
                        (if (length(self.args) > 5) princ("Float")),
                        signature!(c,a2),
                        expression(a3, loop),
                        breakline(),
                        bitvector!(c,self.args[4]),
                        (expression(self.args[5],loop),
                         if (length(self.args) > 5)
                            (princ(","), expression(self.args[6],loop)))  )
          else printf("add_method_property(~I)",
                        args_list(self.args, loop,true)))
        else (write(Compile/alloc_stack, OPT, b),
              print_external_call(c,self, loop)),
        OPT.Compile/alloc_stack :=  b) ]

// unprotected call
[print_external_call(c:c_producer,self:Call_method,loop:any) : void
 -> let m := self.arg, l := self.args, n := 1, ld := m.domain in
     (printf("~I(", c_princ(Compile/functional!(m))),
      if (length(l) > 4) OPT.level :+ 1,
     // was if (length(l) = 1 & (domain!(m) = void) & m.range != float)  l := nil,
      if (length(l) = 1 & domain!(m) = void)  l := nil,
      for x in l
          (if (n != 1) (princ(","), if (length(l) > 4) breakline()),
           let s1 := Compile/psort(ld[n]),
               s2 := Compile/stupid_t(x) in
             (if (s1 Core/<=t object & not(s2 Core/<=t s1))
                 printf("(~I *) ", class_princ(s1))),  // v3.3.13
           expression(x, loop),
           n :+ 1),
      princ(")"),
      if (m.range % tuple & not(OPT.Compile/alloc_stack)) princ("->copyIfNeeded()"), // v3.2.26
      if (length(l) > 4) OPT.level :- 1) ]


// new in 3.0 : really low level method are virtual and only rely on inline compiling
[inline_exp(c:c_producer,self:Call,loop:any) : void
 -> let  p := self.selector, a1 := car(self.args), n := length(self.args) in
       (if (p = mClaire/get_stack) printf("ClEnv->stack[~I]", expression(a1, loop))
        else if (p = safe)                    // v3.2.12 : we had forgotten this !!!!
           let y := compiler.safety in
             (compiler.safety := 1,
              expression(self.args[1],loop),
              compiler.safety := y)
        else if (p = mClaire/base!) printf("ClEnv->base")
        else if (p = mClaire/index! & n = 1) printf("ClEnv->index")
        else if (p = mClaire/push! & n = 1)
          printf("PUSH(~I)", expression(a1, loop))
        else if (p = mClaire/put_stack)
          printf("(ClEnv->stack[~I]=~I)", expression(a1, loop),
                                          expression(self.args[2], loop))
        else if (p = mClaire/set_base)
          printf("(ClEnv->base= ~I)", expression(a1, loop))
        else if (p = mClaire/set_index)
          printf("(ClEnv->index= ~I)", expression(a1, loop))
        else if (p = object!)
          let a2 := self.args[2] in     // a class
              printf("(~I.~I = ~I)",
                     ident(defined(a1)),
                     (if (a2 <= reserved_keyword)
                         (princ("_cl_"), c_princ(string!(a1)))
                      else ident(a1)),
                     (if (a2 = property & (a1.value % property))
                         printf("property::make(~S,~A,~I,~I,~A)",
                                string!(a1),
                                a1.value.open,
                                expression(module!(a1),nil),
                                expression(a1.value.domain,nil),
                                a1.value.mClaire/dispatcher)
                      // new in v3.0.50: trap property -> init dispatcher slot
                      else printf("(~I *) ~I->instantiate(~S,~I)",
                                  class_princ(a2),                  // v3.3.14
                                  expression(a2, loop),
                                  string!(a1),
                                  expression(module!(a1),nil))))
        else if (p = anyObject!)
              printf("((~I *) (*~I)(~I))", class_princ(a1 as class),        // v3.3.16
                        expression(a1,loop),
                        args_list(cdr(self.args), loop, length(self.args) > 2))
        else if fcall?(self) fcall_exp(self,loop)
        else if (length(self.args) > 20)            // v3.2.54
           (if (self.selector = store)
             let l := self.args, n := length(l), m := n / 10  in
               printf("(~I)",
                       (for i in (0 .. m)
                         (printf("(*~I)(~I)", expression(store, loop),
                                 args_list(list{l[j] |
                                                j in ((i * 10 + 1) ..
                                                      (if (i = m) n else (i * 10 + 10))) },
                                                loop, true)),
                          if (i != m) princ(","))))             // v3.1.06
            else error("[216] ~S has more than 10 parameters",self))
        else printf("(*~I)(~I)", expression(self.selector, loop),
                                 args_list(self.args, loop, length(self.args) > 1))) ]


// *******************************************************************
// *       Part 2: Fast dispatch                                     *
// *******************************************************************


// new in v3.00.05: fast dispatch -----------------------------------------

// is the call OK for a fast dispatch? - similar to what is provided by Java :-)
// (a) dictionary or <= 3 restrictions
// (b) args a2->an match all restrictions => all sorts are the same
// (c) a1 is designated  & covered by union of restrictions
fcall? :: property(open = 3)
fcall_exp :: property(open = 3)

Compile/FCLimit :: 3
Compile/FCALLSTINKS:boolean :: false          // v3.2.22 : a boolean to understand

// v3.2.18 : cut the to_CL restriction !
// v3.2.22 : type(a1) <= object is not necessary (implied with the dispatcher case, irrelevant with the enumerated case)
[fcall?(x:Call)  : boolean
  -> let p := x.selector, a1 := x.args[1],
         nProtect := length(list{ y in x.args | c_gc?(y)}) in    // number of args that need a gc
       // (a1 % to_CL & designated?(a1.arg) &           // old: only apply to to_CL
      ( (designated?(a1) | p.mClaire/dispatcher > 0) &  // new v3.2.26: even simpler
           (let l := cdr(x.args), %type:type := {},
              lt := list{Optimize/ptype(c_type(y)) | y in x.args},
              lt2 := cdr(lt),
              lr := get_restrictions(x,lt),
              selOK := ((length(lr) > 0) &
                        (nProtect = 0 |
                         forall(m in lr | not(status!(m)[NEW_ALLOC]))) & // do not remove GC protect !
                        ( (p.mClaire/dispatcher > 0 & length(l) <= 4) |  // use dispatcher <= 4 args
                          length(lr) < FCLimit)),                        // use explicit enumeration
              s := (if (length(lr) > 0) c_srange(lr[1]) else void),
              lrOK := forall( r in lr |
                          (%type :U domain!(r),
                           ( r.domain[1] % class &            // v3.2.16: domain!(m) always a class !
                             (last(r.domain) != listargs) &   // v3.1.06
                             Core/tmatch?(lt2, cdr(r.domain)) &
                             c_srange(r) = s))),
              callOK := (s % {any, void, integer,object} &
                         %type <= object &
                         Optimize/ptype(c_type(a1)) <= %type) in
          (if (FCALLSTINKS & not(selOK & lrOK & callOK) & p.mClaire/dispatcher > 0)
              trace(0,"****> fcall(~S) fails (selectorOK = ~S , lrOK = ~S, callOK = ~S)\n",
                                  x, selOK, lrOK, callOK),
           (selOK & lrOK & callOK)))) ]


// return the list of restrictions that may be involved with the call
[get_restrictions(x:Call, lt:list) : list<method>
 -> let p := x.selector, open_required := (class!(lt[1]).open = system.open),
        lr := list<method>() in
       (if (p.mClaire/dispatcher = 0 & (open_required | p.open = system.open)) nil  // v3.2.24 ! thanks to FLA
        else (for r:restriction in p.restrictions
               (if (r.domain ^ lt)
                  (case r (method lr :add r,
                           any break(shrink(lr,0)))))),
        lr) ]

// generate the fast dispatch code
// if dictionary -> use fcall
[fcall_exp(x:Call,loop:any) : void
  -> let p := x.selector, a1 := x.args[1],             // was (x.args[1] as to_CL).arg,
         lt := list{Optimize/ptype(c_type(y)) | y in x.args},
         lr := get_restrictions(x,lt),
         m := lr[1] as method, s := c_srange(m) in
       (if (s = void) printf("_void_(")
        else if (s = object) printf("_oid_(")
        else if (s = integer & compiler.safety <= 2) printf("_integer_("),
        if (p.mClaire/dispatcher > 0 & length(lt) <= 4)    // use fcall
          (//[4] ---- note: ~S is compiled with fast dispatch // x,
           if (s = object) princ("(ClaireObject *) "),
           printf("~I->fcall(~I)", expression(p,loop),
                                  c_sorted_args(x,m.mClaire/srange,loop,true)))
        else let lr2 :=  list{x in p.mClaire/definition | x % lr} in  // good order
             (//[4] ---- note: ~S is compiled with explicit dispatch (s = ~S) // x, s,
              for m in lr2
               let psort := list{psort(x) | x in m.domain} in    // v3.3.24 --- looks like we reinvent psort ... 
                                 ;(let c := class!(x), sc := sort!(c) in    // sort! = osort :-)
                                 ;   (if (sc = object) c else sc)) |
                                 ; x in m.domain} in
               (if (m != last(lr2))
                   printf("(INHERIT(~I,~I) ? ~I ~I((~I *) ~I) : ~I ",
                       (if (a1 % to_CL) printf("~I->isa",expression(a1.arg,loop))
                        else printf("OWNER(~I)",expression(a1,loop))),
                       expression(domain!(m),loop),
                       (if (s = object) princ("(ClaireObject *)")),   // v3.2.16
                       c_princ(Compile/functional!(m)),
                       class_princ(domain!(m)),                       // v3.3.14
                       c_sorted_args(x,psort,loop,false),
                       breakline)
                 else (printf("~I ~I((~I) ~I)",
                             (if (s = object) princ("(ClaireObject *) ")), // v3.2.16
                             c_princ(Compile/functional!(m)),
                             interface!(PRODUCER,domain!(m)),
                             c_sorted_args(x,psort,loop,false)),
                      for i in (1 .. (length(lr2) - 1)) princ(")")))),
        if (s = void | s = object | s = float | s = integer & compiler.safety <= 2)
           princ(")")) ]


// prints an argument with the proper sort, %cast = true => cast to int
// x is assumed to be of sort OID
[c_sorted_arg(x:any,s:class,loop:any, %cast:boolean) : void
  -> if %cast printf("((int) "),
     if (case x (to_CL osort(x.set_arg) = s)) expression(x.arg,loop)  // v3.3.0
     else if (s = any) expression(x,loop)
     else to_c(PRODUCER,x,s,loop),
     if %cast printf(")") ]

// prints the set of args
[c_sorted_args(x:Call,ls:list,loop:any, %cast:boolean) : void
  -> let i := 0 in
       (for y in x.args
          (if (i != 0) princ(","), i :+ 1,
           c_sorted_arg(y,ls[i],loop,%cast))) ]

// *******************************************************************
// *       Part 3: Specific code for expressions                     *
// *******************************************************************

// prints a bitvector status in a nice manner
[bitvector!(c:c_producer,x:any) : void
  -> case x (integer bitvectorSum(x),
             to_CL bitvector!(c,x.arg),
             to_protect bitvector!(c,x.arg),
             any expression(x,nil)) ]

Compile/bitvectorList :: list("NEW_ALLOC","BAG_UPDATE","SLOT_UPDATE","RETURN_ARG","SAFE_RESULT",
                              "SAFE_GC","STRING_UPDATE")    // v3.3.46

[bitvectorSum(x:integer) : void
 -> if (x = 0) princ("0")
    else let b := false in
          for i in (1 .. 7)                         // v3.3.46
            (if x[i] (if b princ("+") else b := true,
                      princ(bitvectorList[i]))) ]

// print a signature
[signature!(c:c_producer,x:any) : void
 -> case x (list printf("list::domain(~A,~I)", length(x),
                        args_list(list{getC(y) | y in x}, nil, length(x) > 3)),
            to_C signature!(c,x.arg),
            to_protect signature!(c,x.arg),
            List signature!(c,x.args),
            Variable expression(x,nil),
            any printf("<fucking ~S:~S>",owner(x),x)) ]


// patch: remove protection and conversion layers
[getC(x:any) : any
  -> case x (to_CL getC(x.arg),
             to_protect getC(x.arg),
             global_variable (if nativeVar?(x) x                        // v3.3
                              else  to_C(arg = x, set_arg = type)),     // AHA new in v3.0.42
             any x) ]

// assignment for a global-variable (value is an OID) that may require trailing
[gassign(c:c_producer,self:Gassign,loop:any) : void
 -> if self.var.Kernel/store?                                     // still ok in v3.3 since storeable vars use the old pattern
        printf("(STOREI(~I,~I))", expression(self.var, loop),     //!
               expression(get(arg, self), loop))
    else printf("(~I= ~I)", expression(self.var, loop),
                expression(get(arg, self), loop)) ]

[call_slot(c:c_producer,self:Call_slot,loop:any) : void
 -> if self.test
       printf("~A(~I,",
               (if (self.selector.srange inherit? import |
                    self.selector.srange inherit? string |
                    self.selector.srange inherit? array |      // v3.0.66 unknown(array) => null
                    self.selector.srange inherit? object) "NOTNULL"
                else "KNOWN"),
               expression(self.selector.selector, loop)),
    c_member(c, self.arg, psort(domain!(self.selector)),
             self.selector.selector, loop),
    if self.test princ(")") ]

[call_table(c:c_producer,self:Call_table,loop:any) : void
 -> let a := self.selector,
         p := a.params,
         l := self.arg in
       (if self.test printf("KNOWN(~I,", expression(a, loop)),
        printf("(*(~I->graph))[~I]", expression(a, loop),           //!
               (case p
                 (integer
                    printf("~I - ~A", expression(l, loop), p),
                  list printf("~I * ~A + ~I - ~A",                    //<yc> l is a List
                              expression(l.args[1], loop), p[1],
                              expression(l.args[2], loop), p[2])))),
        if self.test princ(")")) ]

[call_array(c:c_producer,self:Call_array,loop:any) : void
 -> if (self.test = float)
        printf("((double *) ~I)[~I]",expression(self.selector, loop),  //!
                 expression(self.arg, loop))
    else printf("((OID *) ~I)[~I]",expression(self.selector, loop),
                 expression(self.arg, loop)) ]

// this method is extensible and can be further refined  if necessary
[update(c:c_producer,self:Update,loop:any) : void
 ->  let p:any := self.selector, a := self.arg,
         v := self.value, x := self.var, s := c_sort(v) in
       (if (case p (relation (known?(p.if_write) & a != put & a != put_store)))
           printf("~I_write(~I,~I)",
                  c_princ(string!(p.name)),
                  expression(x.arg, loop),
                  expression(v,loop))
        else if (case p (relation (p.Kernel/store? | a = put_store)))
           printf("STORE~A(~I,~I)",
                  (if (s = any | s = integer) "I"
                   else if (s = float) "F"
                   else "O"),
                  expression(x, loop),
                  expression(v, loop))
        else printf("(~I = ~I)", expression(x, loop), expression(v, loop))) ]
        // AUDACIEUX: remove parenthesis -> failed

[object_test(c:c_producer,a1:any,pos?:boolean,loop:any) : void
  -> printf("(CTAG(~I) ~I OBJ_CODE)",
            expression(a1, loop), sign_equal(pos?)) ]


[exp_to_protect(c:c_producer,self:to_protect,loop:any) : void                  // v3.0.3
 -> let st := c_type(self.arg) in
     (if (OPT.protection & need_protect(self.arg) &
          not(OPT.alloc_stack & st <= tuple))                                 // v3.2.26 : a temporary tuple should not be protected ...
        let x := self.arg, s := c_sort(x) in
          printf("~A(~I)",gc_protect(s),
                  (if (s inherit? object) printf("~I,~I",
                                                  class_princ(psort(c_type(x) glb s)),   // v3.3.14
                                                  expression(self.arg, loop))
                   else expression(self.arg,loop)))
      else expression(self.arg, loop)) ]


[gc_protect(c:class) : string
  -> if (c = any) "GC_OID"
     else if (c = string) "GC_STRING"
     else if (c = array) "GC_ARRAY"
     else if (c inherit? object) "GC_OBJECT"
     else ""]

[macro(c:c_producer) : void -> nil]
[init_var(c:c_producer,s:class) : void -> nil]
[any_interface(c:c_producer) : void -> princ("OID") ]
[pointer_cast(c:c_producer,s:class) : void -> printf("(~I *)",class_princ(c,s)) ]  // v3.3.14


// v3.2.44:  make this part re-definable for C
[exp_Assign(c:c_producer,self:Assign, loop:any) : void
  -> let x := self.arg, v := self.var in
        printf("~I= ~I", ident(PRODUCER, v), expression(x, loop)) ]   // v3.0.3 AUDACIEUX


// *******************************************************************
// *       Part 4: Specific code for control structures              *
// *******************************************************************

// how to .. handle handler
[stat_handle(c:c_producer,self:Handle,s:any,loop:any) : void
 ->  new_block(),
     printf("ClaireHandler c_handle = ClaireHandler();"),
     breakline(),
     princ("if ERROR_IN "),
     breakline(),
     new_block(),
     statement(self.arg, s, loop),           // v3.3.3: the loop argument is needed for GC protection
     princ("ClEnv->cHandle--;"),
     close_block(),
     printf("else if (belong_to(_oid_(ClEnv->exception_I),~I) == CTRUE)",
            expression(c_code(self.test, any), {})),
     breakline(),
     new_block(),
     princ("c_handle.catchIt();"),
     statement(get(other, self), s, loop),   // same (was put to nil to forbid the use of a return)
     close_block(),
     printf("else PREVIOUS_HANDLER;"),
     close_block() ]

// v3.0.42: the variable s is not necessariuly properly typed
[stat_construct(c:c_producer,self:Construct,s:any,loop:any) : void
  -> if not(s) error("[202] A do should have been used for ~S", self),
     let v := check_var("v_bag", s, loop),
         seed := (case self (List list(), Set set(), Tuple tuple(), any error("BUG: ~S", self))) in
       (new_block(),
        (if known?(of,self) cast!(seed,self.of)),
        if exists(x in self.args | not(c_func(x)))
           printf("OID ~A;~I",v,breakline()),
        printf("~I~I= ~I~I;",
               (if OPT.protection (c.stat :+ 1, printf("GC_ANY("))),   // v3.3.32
               c_princ(s),
               bag_expression(PRODUCER,seed.isa,seed,of(seed),loop), // v3.2
               (if OPT.protection printf(")"))),
        for x in self.args
          let f := c_func(x) in
            printf("~I~I~I~I(~I);", breakline(),
                   (if not(f) statement(x, v, loop)),
                   printf("((~S *) ~I)",
                          (case self (List list, Set set, any tuple)),
                          c_princ(s)),
                   addFast(c),
                   (if f expression(x, loop) else c_princ(v))),
        close_block()) ]

// note: it might be wise to use define_variable to define v ...
// v3.2.42: do not use the simple form if the test needs a GC protection
[stat_while(c:c_producer,self:While,s:any,loop:any) : void
 -> new_block(),
    let f? := (c_func(self.test) & not(self.other) & gc_usage(self.test,loop) = false),
        v := check_var("v_while", s, loop) in
       (if OPT.loop_gc printf("OID gc_local;~I", breakline()),
        if not(f?) printf("~I~A;~I", interface!(boolean),v, breakline()),
        if (s % string) (printf("~I= _oid_(~I);", c_princ(s),expression(false,loop)), breakline()),
        if f?  printf("while (~I)",bool_exp(self.test, not(self.other), loop))
        else (statement((if self.other false else self.test), v, true),
              breakline(),
              printf("while (~A ~I CTRUE)", v,
                      (if self.other princ("!=") else princ("==")))),      // v3.00.05
        breakline(),
        new_block(),
        let bloop := (OPT.loop_gc & gc_usage(self.arg,true) != false) in   // new in v3.0.55
          (if bloop (printf("GC_LOOP;"), breakline()),
           inner_statement(self.arg, {}, (case s (string s, any unknown))),
           if not(f?) statement(self.test, v, true),
           if bloop printf("GC_UNLOOP;")),
        close_block()),
     close_block() ]

[stat_gassign(c:c_producer,self:Gassign,s:any,loop:any) : void
 ->  new_block(),
     printf("~I truc;~I", interface!(c,(if nativeVar?(self.var) getRange(self.var) else any)),
                          statement(get(arg, self), "truc", loop)),     // v3.3
     breakline(),
     if self.var.Kernel/store?  printf("STOREI(~I,truc);", expression(self.var, loop))
     else printf("(~I = truc);", expression(self.var, loop)),
     close_block() ]

[stat_for(c:c_producer,self:For,s:any,loop:any) : void
 -> let v := c_string(c,self.var) in
      (new_block(),
       if OPT.loop_gc printf("OID gc_local;~I", breakline()),
       printf("ITERATE(~I);", c_princ(v)),
       if (s % string) (breakline(), printf("~I= Kernel.cfalse;", c_princ(s))),  // v3.3.42 - Sylvain's optim 
       breakline(),
       if (c_func(self.set_arg) & designated?(self.set_arg))
          printf("for (START(~I); NEXT(~I);)",
                 expression(self.set_arg, loop), c_princ(v))
       else let v2 := v /+ "_support" in
            (printf("bag *~I;~I",c_princ(v2),breakline()),
             statement(self.set_arg, v2, loop),
             printf("for (START(~I); NEXT(~I);)", c_princ(v2), c_princ(v))),
       breakline(),
       let bloop := (OPT.loop_gc & gc_usage(self.arg,true) != false) in   // new in v3.3 :-) copied from while ....
         (if bloop (new_block(), printf("GC_LOOP;"), breakline()),
          if (OPT.profile? & OPT.in_method % object)
             (if not(bloop) new_block(), princ("PRloop(PR_x);"), breakline()), // v3.3.44
          statement(self.arg, {}, (if (s % string) s else unknown)),
          if bloop (printf("GC_UNLOOP;"), close_block()),
          if (OPT.profile? & OPT.in_method % object & not(bloop)) close_block(),
          close_block())) ]

[stat_iteration(c:c_producer,self:Iteration,s:any,loop:any) : void
 -> if not(s) error("[203] you should have used a FOR here:~S", self),
    let v := c_string(c,self.var),
        local := check_var("v_val", s, loop),
        liste := check_var("v_list", s, loop) in
      (new_block(),
       printf("bag *~A; OID ~A;~I",liste, local,breakline()),
       printf("OID ~I,CLcount;~I", c_princ(v), breakline()),
       printf("~I ~I = ~I;",
              statement(self.set_arg, liste, loop),
              c_princ(s),
              printf("~A->clone(~I)", liste,
                     (if known?(of,self)
                         expression(c_code(of(self),type),nil)))),    // v3.2.28
       breakline(),
       printf("for (CLcount= 1; CLcount <= ~A->length; CLcount++)", liste),
       breakline(),
       new_block(),
       printf("~I = (*(~A))[CLcount];", c_princ(v), liste),
       breakline(),
       statement(self.arg, local, true),
       breakline(),
       printf("(*((list *) ~I))[CLcount] = ~A;", princ(s), local),
       close_block(),
       close_block()) ]

[stat_super(c:c_producer,self:Super,s:any,loop:any) : void
 -> let rec := check_var("v_rec", s, loop) in
       (new_block(),
        printf("OID ~A;", rec),
        breakline(),
        for x in self.args
          (printf("~IPUSH(~A);", statement(x, rec, loop), rec),
           breakline()),
        printf("~I~I->super(~I,~A);",
               (case s (string printf("~I=", c_princ(s)))),
               expression(self.selector, loop),
               expression(self.cast_to, loop), length(self.args)),
        close_block()) ]


// last addition in v3.2.44
[stat_let(c:c_producer,self:Let,s:any,loop:any) : void
 -> let ns := c_string(PRODUCER,self.var.pname) in
      (if (ns[1] = 'C' & ns[2] = '%') self.var.pname := gensym()),
     let v := c_string(PRODUCER,self.var), b := OPT.alloc_stack,
         x := get(value, self), f := true in   // f is used for recursively embedded lets
       (new_block(),
        OPT.alloc_stack := false,
        while f
          (if (self % Let*) OPT.alloc_stack := true,            // Let* uses a tuple of vars
           printf("~I ~I", interface!(sort(self.var)), c_princ(v)),
           if c_func(x)
            printf(" = ~I;~I",
               (if bool_exp?(x) bool_exp!(PRODUCER,x,loop) else expression(x, loop)),   // v3.1.12
                   breakline())
           else printf("~I;~I~I",init_var(PRODUCER, sort(self.var)),
                                 breakline(), statement(x, v, loop)),
           if (self % Let*)  OPT.alloc_stack := false,
           if (self.arg % Let)
              (self := self.arg as Let,
               v := c_string(PRODUCER,self.var),
               x := get(value, self))
           else f := false),
        OPT.alloc_stack := b,
        printf("~I", inner_statement(self.arg, s, loop)),
        close_block()) ]

//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| gexp.cl                                                     |
//| Copyright (C) 1994 - 2001 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// ---------------------------------------------------------------------
// Compiling is based upon three methods:
//  - c_func? tests if the CLAIRE form can be represented by a C/ expression.
//    In this case,
//  - expression transforms it into an equivalent C expression.
//    otherwise,
//  - statement takes also a variable as an argument, and transforms a CLAIRE
//    expression into a C statement that assigns the value of the expression
//    into the variable;
//
// A special case occurs when the expression represent a boolean value and is
// functional, we can use bool_exp that returns a C boolean
// ---------------------------------------------------------------------

// *********************************************************************
// *  Contents                                                         *
// *  Part 1: c_func & expression for objects                          *
// *  Part 2: expression for messages                                  *
// *  Part 3: expression for structures                                *
// *  Part 4: boolean optimization                                     *
// *********************************************************************

// the mark //! shows C++ specific code that should be moved

//**********************************************************************
//*          Part 1: c_func & expression for objects                   *
//**********************************************************************

// this methods tells if a CLAIRE instruction can be compiled as an expression,
// as opposed to a statement.
[c_func(self:any) : boolean
 -> case self
      (bag not({ x in self | not(c_func(x))}),
       Construct (if (self % (Set U List U Tuple))
                    (length(self.args) < 15 &
                     not({ x in self.args | not(c_func(x))}))
                  else false),
       If (c_func(self.test) & c_func(get(arg, self)) &
           c_func(get(other, self)) &
           stupid_t(self.arg, self.other) &
           (let n := 4,
                x := self.other in
              while (n > 0)
                case x (If (x := x.other, n :- 1), any break(true)))),
       Assign c_func(get(arg, self)),
       Gassign c_func(get(arg, self)),
       to_protect c_func(get(arg, self)),
       And c_func(self.args),
       Or c_func(self.args),
       Call c_func(self.args),
       Call_method (c_func(self.args) & (self.arg != *close_exception*)),   // test v3.2.58
       Call_slot c_func(get(arg, self)),
       Call_table c_func(get(arg, self)),
       Call_array c_func(get(arg, self)),
       Update (c_func(get(value, self)) &
               c_func(get(arg, self))),
       Cast c_func(self.arg),
       to_C c_func(self.arg),
       to_CL c_func(self.arg),
       any (self % thing | self % integer | self % string | self % char |
            self % float | self % Variable | self % global_variable |
            self % function | self % symbol | self = unknown |
            self % boolean | self % class | self % environment)) ]


// A named object is designed by a C identifier !
expression(self:thing,loop:any) : void -> produce(PRODUCER,self)

// Primitive types rely on the producer to generate code that uses their specific implementation
expression(self:integer,loop:any) : void -> princ(self)
expression(self:any,loop:any) : void -> produce(PRODUCER,self)
expression(self:string,loop:any) : void -> produce(PRODUCER,self)
expression(self:float,loop:any) : void -> princ(self)
expression(self:boolean,loop:any) : void -> produce(PRODUCER,self)
expression(self:environment,loop:any) : void -> produce(PRODUCER,self)
// lexical variables are represented by C variables
expression(self:Variable,loop:any) : void -> ident(PRODUCER,self)

// global_variables are CLAIRE objects
[expression(self:global_variable,loop:any) : void
 -> produce(PRODUCER,self) ]

// builds a set
expression(self:Set,loop:any) : void
 -> bag_expression(PRODUCER,set,self.args,(if known?(of,self) self.of else void),loop)
[expression(self:set,loop:any) : void
 -> if (length(self) = 0 & of(self) = {}) princ("Kernel.emptySet")
    else bag_expression(PRODUCER,set,self,of(self),loop) ]

// builds a tuple
expression(self:Tuple,loop:any) : void
 -> bag_expression(PRODUCER,tuple,self.args,void,loop)
expression(self:tuple,loop:any) : void
 -> bag_expression(PRODUCER,tuple,self,void,loop)

// builds a tuple
expression(self:List,loop:any) : void
 -> bag_expression(PRODUCER,list,self.args,(if known?(of,self) self.of else void),loop)
[expression(self:list,loop:any) : void
 -> if (length(self) = 0 & of(self) = {}) princ("Kernel.nil")
    else bag_expression(PRODUCER,list,self,of(self),loop) ]

//**********************************************************************
//*          Part 2: expression for messages                         *
//**********************************************************************

// General case. Note that the arguments are protected if needed !
//
expression(self:Call,loop:any) : void
 -> inline_exp(PRODUCER,self,loop)

// the other cases will be taken care in the optimization part
[expression(self:Call_method1,loop:any) : void
 -> inline_exp(PRODUCER,self,loop)]

[expression(self:Call_method2,loop:any) : void
 -> inline_exp(PRODUCER,self,loop)]

[expression(self:Call_method,loop:any) : void
 -> inline_exp(PRODUCER,self,loop)]
 

//**********************************************************************
//*          Part 3: expression for structures                       *
//**********************************************************************

// this is an attempt to get rid of useless parenthesis without creating ambuiguous situations
// bexpression(x,loop) adds wrapping ( ) if needed     v3.2.06
[bexpression(self:any,loop:any) : void
  -> case self (Assign printf("(~I)",expression(self,loop)),
                to_C  printf("(~I)",expression(self,loop)),                     // v3.2.44
                integer (if (self < 0)  printf("(~I)",expression(self,loop))    // v3.2.44
                         else expression(self,loop)),                           // avoid (2--2)
                float   (if (self < 0.0)  printf("(~I)",expression(self,loop))
                         else expression(self,loop)),
                any    expression(self,loop)) ]

// if can be represented by an expression
expression(self:If,loop:any) : void
 -> (printf("(~I ?", bool_exp(self.test, true, loop)),
     OPT.level :+ 1,
     breakline(),
     printf("~I :", expression(get(arg, self), loop)),
     breakline(),
     printf("~I )", expression(get(other, self), loop)),
     OPT.level :- 1)

// An assignment is a C expression. It may be an increment (optimization).
// This is a simple variable operation. If loop is on, and the value is
// protected, we use an optimization to save stack space.
// note: GC statements are generic since they don't exist in Java !
[expression(self:Assign,loop:any) : void
 -> let x := self.arg, v := self.var in
      (if (case x (Call_method2
                     (x.arg = *+_integer* & x.args[1] = self.var &  x.args[2] = 1)))
           printf("++~I", expression(v, loop))
       else if (loop & OPT.loop_gc & inner2outer?(x))
            gc_protection_exp(PRODUCER,v,true,(case x (to_protect x.arg, any x)),
                             loop)
       else exp_Assign(PRODUCER,self,loop)) ]  // v3.2.44
       // WAS (~I = ~I)

// this is the case where the value is to be protected
[expression(self:to_protect,loop:any) : void
 -> exp_to_protect(PRODUCER,self,loop) ]                                    // v3.0.3

     
// an assignment is a C expression
// This is a global variable
[expression(self:Gassign,loop:any) : void
 -> gassign(PRODUCER,self,loop) ]

// a conjunction is also a C expression
[expression(self:And,loop:any) : void
 -> let b := (length(self.args) > 5) in
       (for x in self.args
          (printf("(~I ? ", bool_exp(x, true, loop)),
           if b breakline()),
        expression(true,loop),
        for x in self.args printf(": ~I)",expression(false,loop))) ]

// same thing for a disjunction
[expression(self:Or,loop:any) : void
 -> let b := (length(self.args) > 5) in
       (for x in self.args
          (printf("(~I ? ~I : ", bool_exp(x, true, loop), expression(true,loop)),
           if b breakline()),
        expression(false,loop),
        for x in self.args princ(")")) ]


// to_CL(x) produces a CLAIRE id from an external representation
expression(self:to_CL,loop:any) : void
 -> to_cl(PRODUCER,self.arg, self.set_arg, loop)

// to_C(x) produces an external representation from a CLAIRE id
expression(self:to_C,loop:any) : void
 -> to_c(PRODUCER,self.arg, self.set_arg, loop)

// C_cast(x) produces a cast for C++
expression(self:C_cast,loop:any) : void
 -> cast!(PRODUCER,self,loop)

// reads a slot.
// when the test is on, we use two functions NOTNULL/KNOWN(p,x,x->p)
[expression(self:Call_slot,loop:any) : void
 -> call_slot(PRODUCER,self,loop) ]

// reads an (integer) table
[expression(self:Call_table,loop:any) : void
 -> call_table(PRODUCER,self,loop)]

// reads an array
[expression(self:Call_array,loop:any) : void
 -> call_array(PRODUCER,self,loop) ]

// places a value in a slot with similar conventions
// if the selector is external, there is an interface
[expression(self:Update,loop:any) : void
 -> update(PRODUCER,self,loop) ]


//**********************************************************************
//*          Part 4: the logical expression compilation                *
//**********************************************************************

// v3.0.03: bool_exp can be used for a test in an If => always
// v3.0.22: self must be of range boolean but we now support a sort any

// this is the boolean compiler. An automatic computation of negation is
// included. The flag pos? tells if the assertion is positive. When a
// negation occurs, we simply change the flag. At the end of compiling,
// the flag is used to generate == or != according to this method:
// generate a equality/ difference
//
sign_equal(self:boolean) : void -> (if self princ("==") else princ("!="))

// generate a conjunction/disjunction
sign_or(self:boolean) : void -> (if self princ("||") else princ("&&"))

// this is the default compilation of a logical expression
// NEW: we know that self is a boolean,
// the (any -> boolean) conversion is done at the optimizer level
// v3.3.12: the droping of to-C means that the sort cannot be computed
// hence the test for c_sort != bool is only on global variables
[bool_exp(self:any,pos?:boolean,loop:any) : void
 ->  any_bool_exp(self,pos?,loop,
         not(self % global_variable & not(nativeVar?(self)))) ]


// v3.3.12: this method works for both OID and true bools
[any_bool_exp(self:any,pos?:boolean,loop:any,nat?:boolean) : void
 ->  printf("(~I ~I ~I)", bexpression(self, loop),              // v3.00.05
            (if not(pos?) princ("!=") else princ("==")),
            (if not(nat?) to_cl(PRODUCER,true,boolean,loop)
             else expression(true,loop))) ]


// if we have a CL, we know that the self.arg is of type boolean
[bool_exp(self:to_CL,pos?:boolean,loop:any) : void
  -> bool_exp(self.arg,pos?,loop) ]

// an if may be used as a test, especially within a member
// if there is not else clause, it is an and.
[bool_exp(self:If,pos?:boolean,loop:any) : void
 -> if self.other
        printf("(~I ? ~I : ~I)", bool_exp(self.test, true, loop),
                                 bool_exp(self.arg, pos?, loop),
                                 bool_exp(self.other, pos?, loop))
     else printf("(~I ~I ~I)", bool_exp(self.test, pos?, loop),
                 sign_or(not(pos?)), bool_exp(self.arg, pos?, loop)) ]

// for a AND, we can used the && C operation
[bool_exp(self:And,pos?:boolean,loop:any) : void
 -> let l := self.args, m := length(l), n := 0, %l := OPT.level in
       (OPT.level :+ 1,
        for x in l
          (n :+ 1,
           if (n = m) bool_exp(x, pos?, loop)
           else (printf("(~I ~I ", bool_exp(x, pos?, loop), sign_or(not(pos?))),
                 OPT.level :+ 1,
                 breakline())),
        for x in (2 .. m) princ(")"),
        OPT.level := %l)  ]

// idem for OR: we use ||
[bool_exp(self:Or,pos?:boolean,loop:any) : void
 -> let l := self.args, m := length(l), n := 0, %l := OPT.level in
       (OPT.level :+ 1,
        for x in l
          (n :+ 1,
           if (n = m) bool_exp(x, pos?, loop)
           else (printf("(~I ~I ", bool_exp(x, pos?, loop), sign_or(pos?)),
                 OPT.level :+ 1,
                 breakline())),
        for x in (2 .. m) princ(")"),
        OPT.level := %l) ]

// some special functions are open coded when used in a logical test
[bool_exp(self:Call_method1,pos?:boolean,loop:any) : void
 -> let m := self.arg, a1 := self.args[1] in
       (if (m = *not*)
           (if (a1 % to_CL) any_bool_exp(a1.arg, not(pos?), loop, true)
            else any_bool_exp(a1, not(pos?), loop,false))     // v3.3.12 - was :  & a1 % to_CL
        else if (m = *known*) equal_exp(PRODUCER,a1, not(pos?), unknown, loop)
        else if (m = *unknown*) equal_exp(PRODUCER,a1, pos?, unknown, loop)
        else if (m.range <= boolean)
           printf("(~I ~I ~I)", expression(self, loop), sign_equal(pos?), expression(true,loop))
        else bool_exp@any(self, pos?, loop)) ]

// same thing for two arguments functions
[bool_exp(self:Call_method2,pos?:boolean,loop:any) : void
 -> let m := self.arg, p := m.selector, lop := PRODUCER.open_comparators,
        a1 := self.args[1], a2 := self.args[2] in
      (if (p = !=) equal_exp(PRODUCER,a1, not(pos?), a2, nil)
       else if (p = identical?) equal_exp(PRODUCER,a1, pos?, a2, true)
       else if (p = =) equal_exp(PRODUCER,a1, pos?, a2, nil)
       else if (p % lop & domain!(m) % {float,integer})
           printf("(~I ~I ~I)", expression(a1, loop),
                  (if pos? print(p)
                   else print(lop[((get(lop, p) + 1) mod 4) + 1])),
                  expression(a2, loop))
      ;  else if (m.selector = % & a2 = object)          // v3.2.24
      ;     object_test(PRODUCER,a1,pos?,loop)
        else if (m = *nth_integer*)
           printf("(~I~I)", (if not(pos?) princ("!")),
                            bitvector_exp(PRODUCER,a1,a2,loop))
        else if (p = inherit? & domain!(m) = class)
         printf("(~I~I)", (if not(pos?) princ("!")),
                          inherit_exp(PRODUCER,a1,a2,loop))
       else if (m.range <= boolean)
          printf("(~I ~I ~I)", expression(self, loop), sign_equal(pos?), expression(true,loop))
       else bool_exp@any(self, pos?, loop)) ]

// v3.1.12 -> recognize pure boolean expression
[bool_exp?(x:any) : boolean
  -> case x (to_CL bool_exp?(x.arg),
             Call_method let p := x.arg.selector in
                            ((x.arg.range = boolean &           // v3.2 : protection !
                              (p = = | p = != | p = > | p = >= | p = < | p = <=)) |
                             (p = not & bool_exp?(x.args[1]))),
             any false)]


// produces a list of C expressions, separated by commas
[args_list(self:bag,loop:any,bk?:boolean) : void
 -> let %first := true in
       (if bk? OPT.level :+ 1,
        for x in self
          (if %first (expression(x, loop), %first := false)
           else printf(",~I~I", (if bk? breakline()),
                       expression(x, loop))),
        if bk? OPT.level :- 1) ]

// this method checks that a proposed variable is different from the
// imported one, else it add a mark.
check_var(self:string,s:any,loop:any) : string
 -> (if (self = s | self = loop) self /+ "1" else self)


build_Variable(s:string,t:any) : Variable
 -> Variable!(symbol!(s), 0, t)


//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| gstat.cl                                                    |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// statement is implemented as a general method that calls a restriction
// self_statement which is defined with many restrictions.
// The argument s is supposed to be the named of the C variable in which the
// result of the evaluation must be placed. s is () when the result is not
// used.
// The argument loop tells how the result is to be used:
//     loop = false means that the code will be evaluated at most once
//     loop = true means that the result may be evaluated more than once.
//     loop = s (sort) means that we are inside an all, while or until.
//         if s = unknown, then the return does only a break.

//**********************************************************************
//*  Table of contents:                                                *
//*          Part 1: Unfolding of complex expressions                  *
//*          Part 2: Basic control structures                          *
//*          Part 3: iteration                                         *
//*          Part 4: CLAIRE-specific structures                        *
 //**********************************************************************


//**********************************************************************
//*          Part 1: Unfolding of complex expressions                  *
//**********************************************************************

// this is a crisp-and-clever piece by <yc> :-), which is a little bit tricky
// this is brand new and much better than the previous strategy !
// HOWEVER, if only works for list of arguments whose evaluation order is not specified !

// this function is used to unfold complex expressions that should be compiled as
// expressions and not statements. It takes a list of arguments l and returns the
// embedded Lets that defines the necessary variable or nil (nothing is needed)
// this list is of the form  (a1 .. am) where
//     m is the number of statement args in l
//     ai is a Let that defines the i-th variable corresponding to the i-th bad guy
unfold_args(l:list) : list
  ->  let lbad := list{i in (1 .. length(l)) | not(c_func(l[i]))} in // list of indices
        (//[5] unfold -> ~S : ~S - ~S // list{l[x] | x in lbad}, list{c_sort(l[x]) | x in lbad}, list{stupid_t(l[x]) | x in lbad},
         list{ Let(var = Variable!(gensym() /+ "UU", 0, c_type_sort(l[i])),
                   value = l[i]) | i in lbad}   )

// we can infer a type but the sort must be preserved
// v3.2.40 : If the stupid type is void, we need to use a precise type.
c_type_sort(x:any) : type
 -> let s := c_sort(x), t := stupid_t(x) in
     (//[5] AHA infer a stupid type ~S [sort ~S] in ~S // t,s,x,
      if (s = void) osort(c_type(x))            // v3.2.40: sort = void => the value is not needed
      else if sort=(osort(t),s) t
      else s)

// uses the previous list to use the variable instead of the Fold.
// l is the list of arguments 
unfold_arg(l:list,ld:list,x:any) : any
 -> let i := 1, j := 0, m := length(l) in
       (if (while (i <= m)
             (if not(c_func(l[i]))
                 (j :+ 1, (if (l[i] = x) break(true)))
              else if (l[i] = x) break(false),
              i :+ 1))
           var(ld[j])
        else l[i])

// creates the Let from the ldef definition and places the statement x in the body
unfold_use(ldef:list,x:any,s:any,loop:any) : void
 -> let  n := length(ldef), v := verbose() in
      (verbose() := 0,                  // v3.1.06
       if not(ldef) error("[internal] design bug c_func(~S) should be true",x),
       if (c_type(x) = {}) s := void,                     //  <yc> error -> no value
       for i in (1 .. (n - 1)) ldef[i].arg := ldef[i + 1],
       arg(ldef[n] as Let) := x,
       verbose() := v,                  // not very elegant !
       self_statement(ldef[1] as Let,s,loop))

//**********************************************************************
//*          Part 2: Basic control structures                          *
//**********************************************************************

// The general definition.
// if functional, the best compiling is into an expression
[statement(self:any,s:any,loop:any) : void
 -> let b := OPT.alloc_stack in
      (if not(self % ((Tuple U Do) U Let)) OPT.alloc_stack := false,   // v3.2.26
       if c_func(self)
         (if (s % string &
              c_sort( (case self (to_CL self.arg, any self))) != void)
           printf("~I = ~I;~I", c_princ(s),                           // v3.1.12 -> use bol_exp!
                  (if bool_exp?(self) bool_exp!(PRODUCER,self,loop) else expression(self, loop)),
                  breakline())
          else if (self % If) self_statement(self, s, loop)
          else if (self % delimiter)
             error("[201] Loose delimiter in program: ~S", self)
          else stat_exp(PRODUCER,self,loop))    // new: v3.0.60: include a few tricks
        else if (self % Call_method & self.arg = *close_exception* & c_func(self.args[1])) // v3.3.34
          printf("~I;~I", expression(self, loop), breakline())    // v3.2.58
        else self_statement(self, s, loop),
        OPT.alloc_stack := b) ]


// makes a bag of statements.
// The value cannot be ignored: it is considered as an error
// (a do should have been used)
[self_statement(self:Construct,s:any,loop:any) : void
 -> stat_construct(PRODUCER,self,s,loop) ]

// A if is easy to compile. We check if the logical compiler can be used
// we now assume that the test retuns a boolean !
[self_statement(self:If,s:any,loop:any) : void
 -> if c_func(self.test)
      (printf("if ~I", bool_exp(self.test, true, loop)),
       breakline(),
       princ(" "),
       if (get(arg, self) % If) new_block(),
       statement(get(arg, self), s, loop),
       if (get(arg, self) % If) close_block(),
       if (s % string | get(other, self))
          let xe := get(other, self) in
              (if not(xe % If) OPT.level :+ 1,
               printf("else ~I", statement(xe, s, loop)),
               if not(xe % If) OPT.level :- 1))
    else let v := c_string(PRODUCER,gensym() /+ "I") in
            (new_block(),
             // printf("// type ~S: test is ~S\n",ti,self.test),
             printf("~I ~A;~I~I", interface!(boolean),
                    v,breakline(), statement(self.test, v, loop)),
             breakline(),
             OPT.level :+ 1,
             printf("if (~A == ~I) ~I",                       //<FXJ> MACRO
                    v, produce(PRODUCER,true), statement(get(arg, self), s, loop)),
             OPT.level :- 1,
             // breakline(),
             if (s % string | get(other, self))
                printf("else ~I",statement(get(other, self), s, loop)),
             close_block()) ]

// a DO is a simple C block
[self_statement(self:Do,s:any,loop:any) : void
 -> if (length(self.args) = 1) statement(self.args[1], s, loop)
    else let l := self.args, m := length(l), b := OPT.alloc_stack, n := 0 in
           (OPT.alloc_stack := false,
            new_block(),
            inner_statement(self, s, loop),
            close_block()) ]

// this method is used to avoid creating sub-blocks when un-necessary
[inner_statement(self:any,s:any,loop:any) : void
 -> case self
      (Do let l := self.args, m := length(l), b := OPT.alloc_stack, n := 0 in
             (OPT.alloc_stack := false,
              for x in l
                (n :+ 1,
                 if (n = m) (OPT.alloc_stack := b, inner_statement(x, s, loop))
                 else if x inner_statement(x, {}, loop))),
       any statement(self,s,loop)) ]

// a Let is a local variable declaration
[self_statement(self:Let,s:any,loop:any) : void
 -> stat_let(PRODUCER,self,s,loop) ]


// --------------- logical combinations and/or -------------------------------

// note: we cannot use unfolding because the order of evaluation is important !
// AND is compiled with IF: as soon as an argument is false, the result is false.
[self_statement(self:And,s:any,loop:any) : void
  -> let v := check_var("v_and", s, loop) in
       (new_block(),
        printf("~I~A;", interface!(boolean), v),
        breakline(),
        for x in self.args
          (new_block(),
           printf("~Iif (~A == ~I) ~I~I; ~Ielse ",    //<FXJ> MACRO
                  statement(x, v, loop), v, produce(PRODUCER,false),
                  (case s (string printf("~I =", c_princ(s)))),
                  expression(false,loop), breakline())),
        case s
         (string printf("~I = ~I;", c_princ(s),expression(true,loop)),
          any printf("~I;",expression(true,loop))),
        for x in self.args close_block(),
        close_block()) ]

// same thing for OR
[self_statement(self:Or,s:any,loop:any) : void
 -> let v := check_var("v_or", s, loop) in
       (new_block(),
        printf("~I~A;", interface!(boolean), v),
        breakline(),
        for x in self.args
          (new_block(),
           printf("~Iif (~A == ~I) ~I~I; ~Ielse ",          //<FXJ> MACRO
                  statement(x, v, loop), v, produce(PRODUCER,true),
                  (case s (string printf("~I =", c_princ(s)))),
                  expression(true,loop), breakline())),
        case s
         (string printf("~I = ~I;", c_princ(s),expression(false,loop)),
          any printf("~I;",expression(false,loop))),
        for x in self.args close_block(),
        close_block()) ]

// --------------- WHILE   ------------------------------------------
// if it is possible the logical compiler is used to produce a better code
[self_statement(self:While,s:any,loop:any) : void
  -> stat_while(PRODUCER,self,s,loop) ]

// a assignment can be compiled directly if the value does not matter.
// Here this is the simple assignment, with a true variable
[self_statement(self:Assign,s:any,loop:any) : void
 -> let v := self.var, x := self.arg,
        %s:boolean := (loop &  OPT.loop_gc & inner2outer?(x)),
        y := (if (%s & x % to_protect) x.arg else x) in    // avoid double protection
      (if (s % string)
          printf("~I~I ~I;~I", new_block(), statement(y, s, loop),
                  (if %s gc_protection_exp(PRODUCER,v,false,s,loop)
                   else printf("~I = ~I",ident(v.pname), c_princ(s))),
                  close_block())
       else if %s
          printf("~I~I ~I;~I",
                 new_block(), statement(y, c_string(PRODUCER,v), loop),
                 gc_protection_exp(PRODUCER,v,true,v,loop),              // u = v => purely for protection
                 close_block())
       else statement(x, c_string(PRODUCER,v), loop)) ]

// This is the global variable assignment
[self_statement(self:Gassign,s:any,loop:any) : void
  -> stat_gassign(PRODUCER,self,s,loop) ]

// this is the case where the value is to be protected
// note: this should use the PRODUCER ...
[self_statement(self:to_protect,s:any,loop:any) : void
 -> if (OPT.protection & s % string)
        let c := c_sort(self.arg) in
          (new_block(),
           PRODUCER.stat :+ 1,                         // v3.3.32
           printf("~I~A(~I~I);", statement(self.arg, s, loop),
                  gc_protect(c),
                  (if (c inherit? object)
                     (class_princ(psort(c_type(self.arg))), princ(","))),   // v3.3.34
                  c_princ(s)),
           close_block())
     else statement(self.arg, s, loop) ]

//**********************************************************************
//*          Part 3: iteration                                         *
//**********************************************************************

// generates the iteration code for a "for x in S ..." expression , once
// all optimization based on code substitution have been performed.
[self_statement(self:For,s:any,loop:any) : void
  -> stat_for(PRODUCER,self,s,loop) ]

// here the value is expected to be important, otherwise an error is raised.
// THIS IS ONLY APPLIED TO COLLECT
[self_statement(self:Iteration,s:any,loop:any) : void
  -> stat_iteration(PRODUCER,self,s,loop) ]

//------------- compiling a return -------------------------------------
// a return inside a loop is compiled with a break, the C variable should be
// in the loop argument
[self_statement(self:Return,s:any,loop:any) : void
 -> if (loop = unknown)
        (new_block(),
         statement(self.arg, {}, {}),
        // breakline(),
         princ("break;"),
         close_block())
     else if (loop % string)
        (new_block(),
         printf("~Ibreak;", statement(self.arg, loop, {})),
         close_block())
     else error("[204] break not inside a For or While:~S", self) ]

//**********************************************************************
//*          Part 4: CLAIRE-specific structures                        *
//**********************************************************************

// ------------- Messages and optimized instructions ------------------------

// this is one example on how to unfold: a Call
[self_statement(self:Call,s:any,loop:any) : void
 -> let l := args(self), ld := unfold_args(l) in
      unfold_use(ld, Call(selector(self),
                          list{unfold_arg(l,ld,z) | z in l}), s, loop) ]



// A call method is now simpler with unfolding !
[self_statement(self:Call_method,s:any,loop:any) : void
 -> let l := args(self), ld := unfold_args(l) in
       unfold_use(ld, Call_method(arg = self.arg,
                                  args = list{unfold_arg(l,ld,z) | z in l}), s, loop) ]

[self_statement(self:Call_method1,s:any,loop:any) : void
 -> let l := args(self), ld := unfold_args(l) in
       unfold_use(ld, Call_method1(arg = self.arg,
                                  args = list{unfold_arg(l,ld,z) | z in l}), s, loop)  ]

[self_statement(self:Call_method2,s:any,loop:any) : void
 -> let l := args(self), ld := unfold_args(l) in
       unfold_use(ld, Call_method2(arg = self.arg,
                                  args = list{unfold_arg(l,ld,z) | z in l}), s, loop)]


// The dynamic version of SUPER is not really optimized
//
[self_statement(self:Super,s:any,loop:any) : void
  -> stat_super(PRODUCER,self,s,loop) ]

// trivial
//
[self_statement(self:Cast,s:any,loop:any) : void
 -> statement(self.arg, s, loop)]

//-------------- compiling a handle -------------------------------------
// compiling of exception handling is a little tricky since we must find
// the right handler that matches the error. This is why a stack of
// environment is kept (Exc_env).
// Longjmp gives the basic tool, on top of which we add
// an object layer (belong_to)
//
self_statement(self:Handle,s:any,loop:any) : void
 -> stat_handle(PRODUCER,self,s,loop)


//; to_CL(x) produces a CLAIRE id from an external representation
[self_statement(self:to_CL,s:any,loop:any) : void
 -> case s
      (string let varg := build_Variable(string!(gensym("V_CL")),self.set_arg),
                  s2 := (if (self.set_arg = void) any else self.set_arg) in
                (new_block(),
                 printf("~I ~I;", interface!(s2), expression(varg,loop)),
                 statement(self.arg, c_string(PRODUCER,varg), loop),
                 breakline(),
                 printf("~A=~I;", s,
                        to_cl(PRODUCER, varg, self.set_arg, loop)),
                 close_block()),
       any statement(self.arg, s, loop)) ]

// to_C(x) produces an external representation from a CLAIRE id
//
[self_statement(self:to_C,s:any,loop:any) : void
 -> case s
      (string let varg := build_Variable("V_C", any) in //  YC: was c_type(self.arg)) 28/8
                (new_block(),
                 printf("~I ~I;",
                        any_interface(PRODUCER),               //<FXJ>: PATCH!   in Java: ClaireAny (was OID)
                        ident(PRODUCER,varg)),                 //<FXJ>: PATCH!   ident(PRODUCER...
                 statement(self.arg, c_string(PRODUCER,varg), loop),
                 breakline(),
                 printf("~A=~I;", s, to_c(PRODUCER,varg, self.set_arg, loop)),
                 close_block()),
       any statement(self.arg, s, loop)) ]

// same for a cast
// v3.2.06: the case where self.arg is of type any is painful => it is forbiden in osystem.cl
[self_statement(self:C_cast,s:any,loop:any) : void
 -> case s
      (string let varg := check_var("V_CC", s, loop),     // a string
                  s2 := self.set_arg,
                  s3 := stupid_t(self.arg),
                  t2 := (osort(s2) join s3) in     // v3.2.06 -> v3.3.0 (osort)
                (new_block(),
                 define_variable(PRODUCER,t2,varg),
                 breakline(),
                 statement(self.arg, varg, loop),
                 printf("~A= ~I ~A;", s, pointer_cast(PRODUCER,s2), varg),   //<FXJ> no * in Java ...
                 close_block()),
       any statement(self.arg, s, loop)) ]


//------------- compiling slot read/write -------------------------------
// reads a slot.
[self_statement(self:Call_slot,s:any,loop:any) : void
 -> let v_name := string!(gensym()),                         // v3.1.04
        varg := build_Variable(v_name, c_type(self.arg)) in
       (new_block(),
        printf("~I ~I;", interface!(sort(varg)),
               expression(varg, {})),
        breakline(),
        statement(self.arg, v_name, loop),
        breakline(),
        case s (string printf("~I = ", c_princ(s))),
        expression(Call_slot(selector = self.selector,  arg = varg), loop),
        princ(";"),
        close_block()) ]

// reads an table.
[self_statement(self:Call_table,s:any,loop:any) : void
 -> let v_name := string!(gensym()),                         // v3.1.04
        varg := build_Variable(v_name, c_type(self.arg)) in
       (new_block(),
        printf("~I ~I;", interface!(sort(varg)),
               expression(varg, {})),
        breakline(),
        statement(self.arg, v_name, loop),
        breakline(),
        case s (string printf("~I = ", c_princ(s))),
        expression(Call_table(selector = self.selector, arg = varg), loop),
        princ(";"),
        close_block()) ]

// reads an array.
[self_statement(self:Call_array,s:any,loop:any) : void
 -> let varg1 :=  build_Variable("va_arg1", array),
        varg2 :=  build_Variable("va_arg2", integer)  in
     (new_block(),
      printf("~I ~I;", interface!(array),expression(varg1, {})),
      breakline(),
      printf("~I ~I;", interface!(integer),expression(varg2, {})),
      breakline(),
      statement(self.selector, "va_arg1", loop),
    //  breakline(),
      statement(self.arg, "va_arg2", loop),
    //  breakline(),
      case s (string printf("~I = ", c_princ(s))),
      expression(Call_array(selector = varg1, arg = varg2, test = self.test), loop),
      princ(";"),
      close_block()) ]

// places a value in a slot with similar conventions
// note that the value returned is self.value, so the type should not be
// weakened
// new in v.3.00.42: handles add case => call the demon
[self_statement(self:Update,s:any,loop:any) : void
 ->  let X := self.var,
         p := self.selector,
         s1 := (case X
                 (Call_slot domain!(X.selector),
                  Call_array integer,
                  any any U p.domain)),   // Call_table
         s2 := (case X
                 (Call_slot (if (self.arg = add) member(X.selector.range)
                             else X.selector.range),
                  Call_array (if (X.test Core/<=t float) float else any),
                  any any U (if (self.arg = add) member(p.range)
                             else p.range))),
         ss1 := stupid_t(self.var.arg),
         ss2 := stupid_t(self.value),
         %arg := (if (not(ss1 Core/<=t psort(s1)) & ss1 Core/<=t object)
                      C_cast(arg = self.var.arg, set_arg = psort(s1))
                  else self.var.arg),
         %value := (if (not(ss2 Core/<=t psort(s2)) & ss2 Core/<=t object)
                       C_cast(arg = self.value, set_arg = psort(s2))
                    else self.value),
         varg1 := Variable!(gensym(), 0, s1),
         varg2 := Variable!(gensym(), 0, s2),
         b1 := c_func(%arg) in
       (new_block(),
        printf("~I ~I ~I; ", interface!(psort(s1)), expression(varg1, {}),
                             (if b1 (printf("= ~I",expression(%arg, {}))))),   // v3.3
        breakline(),
        printf("~I ~I;", interface!(psort(s2)), expression(varg2, {})),
        breakline(),
        if not(b1) statement(%arg, c_string(PRODUCER,varg1), loop),            // v3.3 :
        // breakline(),
        statement(%value, c_string(PRODUCER,varg2), loop),
        // breakline(),
        case s (string printf("~I = ", c_princ(s))),
        expression(Update(selector = p,
                            arg = (if (self.arg = add) add // v3.0.44
                                   else if (sort(varg1) = any) varg1
                                   else to_CL(arg = varg1, set_arg = sort(varg1))),
                            value = varg2,
                            var = (let xx := copy(X) in
                                         (put(arg, xx, varg1), xx))),
                     loop),
        princ(";"),
        close_block()) ]

//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| gsystem.cl                                                  |
//| Copyright (C) 1994 - 2003 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

//**********************************************************************
//* Contents                                                           *
//*          Part 1: Global_variables & producer interface             *
//*          Part 2: Module Compiler Interface                         *
//*          Part 3: File Compiler                                     *
//*          Part 4: Function Compiler                                 *
//**********************************************************************


//**********************************************************************
//*          Part 1: Global_variables                                  *
//**********************************************************************

// ----------------------- inline coding --------------------------------
// here we have a list of methods that we want to handle in a special way
// these variables exist already
Compile/*?_interval* :: (set! @ Interval) 
Compile/*--_integer* :: (.. @ integer)
Compile/*+_integer* :: (+ @ integer)
Compile/*nth_integer* :: (nth @ integer)
Compile/*nth_list* :: (nth @ list)
Compile/*nth_1_bag* :: (nth_get @ bag)
Compile/*nth_string* :: (nth @ string)
Compile/*nth_1_string* :: (nth_get @ string)
Compile/*nth=_list* :: (nth= @ list)
Compile/*not* :: (not @ any)
Compile/*known* :: (known? @ any)
Compile/*unknown* :: (unknown? @ any)
Compile/*not_equal* :: (!= @ any)
Compile/*contain* :: (contain? @ list)
Compile/*min_integer* :: (min @ integer)
Compile/*max_integer* :: (max @ integer)
Compile/*length_array* :: (length @ array)
Compile/*length_bag* :: (length @ bag)
Compile/*close_exception* :: (close @ exception)            // v3.2.58  */


// new: the target code production (the part that depends on the target language) is
// encapsulated with a producer object
producer <: thing(
   open_comparators:list[operation],      // list of comparison ops that are inlined (the order matters!!)
   open_operators:list[operation],        // list of arithmetic operators that are inlined
   body:any = 0,                          // used to store the body of the current method
   extension:string,                      // extension for generated files
   comment:string,                        // a string that designates the target language
   interfaces:list,                       // used to translate imported to C/.. entities
   stat:integer = 0)                      // v3.3.32: stats about GC protection

claire/PRODUCER:producer :: unknown

// most standard method: call the producer to print the ident from a symbol
ident(self:symbol) : void -> ident(PRODUCER,self)
ident(self:thing) : void -> ident(PRODUCER,self.name)
ident(self:class) : void -> ident(PRODUCER,self.name)
interface!(c:class) : void -> interface!(PRODUCER,c)
class_princ(c:class) : void -> class_princ(PRODUCER,c)

// we simply use some smart identation. True pretty_printing will be left to bc
indent_c() : any
 -> (let x := OPT.level in while (x > 0) (princ("  "), x :- 1))

breakline() : any -> (princ("\n"), indent_c())

// adds a new C block with the condensed option
new_block() : void
 -> (OPT.level :+ 1, princ("{ "))

// closes the current C block
close_block() : void -> (OPT.level :- 1, princ("} "), breakline())

// TODO: define a status = 3 for the PRODUCER class that tells that is it extensible
(producer.open := 3)

//*********************************************************************
//*          Part 2: Module Compiler Interface                        *
//*********************************************************************

// NOTE/ THIS PART MUST BE COMPLETELY RE-ORGANIZED
// -> the class2file mode is defined in the *gen part
//    the interface stuff as well

// a small test function for the compiler
claire/c_test(x:any) : void
 -> (let t := c_type(x),
         s := osort(t),
         u := c_code(x, s),
         f := Compile/c_func(u) in
       (printf("type -> ~S [sort ~S]\n", t, s),
        printf("opt[~S] -> ~S \n", owner(u), u),
        if f printf("exp  -> ~I\n", expression(u, nil))
        else printf("stat -> ~I\n", statement(u, "result", nil))))


// v3.2.32
[c_test(m:method) : void
  -> when l := get(formula,m) in
        (//[0] ---- Compiling ~S ---- // m,
        OPT.in_method := m,
        OPT.protection := false,
        OPT.allocation := false,
        if (OPT.loop_index > 0) OPT.loop_index := 0,
        OPT.loop_gc := false,
        OPT.Optimize/use_update := false,
        OPT.Optimize/use_nth= := false,
        OPT.Optimize/use_string_update := false,   // v3.3.46
        OPT.Optimize/max_vars := 0,
        OPT.Optimize/online? := false,
        OPT.legal_modules := module.instances,
        // start make_c_function ....
        PRODUCER.body := l.body,
        let s := void,
            %body := (s := check_sort(m), PRODUCER.body),
            %end := protect_result(PRODUCER, s, OPT.protection, m) in
         (printf("Opt => ~S \n\n",%body),
          new_block(),
          print_body(%body,%end,s,l.body, true)),
        OPT.in_method := unknown ) ]

// compile the modules and check that no necessary modules is not
// declared
[claire/compile(self:module) : void
 -> OPT.need_modules := {},
      let l1:bag := parents(Reader/add_modules(list(self))) in
      (OPT.legal_modules := set!(l1),
       if compiler.class2file?
          (//[2] **** Compiling the module ~A [v. 3.~A - verbose:~A opt:~S] // string!(self.name), compiler.version, verbose(), compiler.optimize?,
           // OPT.module! := self, v0.02
           OPT.outmodule := fopen(compiler.source /+ *fs* /+ c_string(PRODUCER,self.name) /+ PRODUCER.extension,"w"),
           generate_files(self),
           begin(self),                    // v3.0.3
           generate_classes(self),
           generate_c2f(self),
           end(self))                      // module -> file in the ClassToFile mode
        else (//[5] call generate_files ~S  // self,
              generate_files(self),                // files to files
              generate_f2f(self),                  // module -> file in the FileToFile mode
              generate_interface(self, OPT.legal_modules)),
       l1 := difference(set!(OPT.need_modules), OPT.legal_modules),
       //[5] ++++ v3.3.32 info: ~A GC protection inserted. // PRODUCER.stat,
       if l1 trace(2, "---- WARNING: ~S should be declared for ~S\n", l1, self)) ]

// the first part is to generate the C files in the FileToFile mode
[generate_files(self:module) : void
 ->  //[0] ==== Generate ~A files for module ~S [verbose = ~A, Opt? = ~S] // PRODUCER.comment, self, verbose(),compiler.optimize?,
     OPT.instructions := list<any>(),
     OPT.properties := set<property>(),
     OPT.objects := list<object>(),
     OPT.functions := list<any>(),
     OPT.need_to_close := set<any>(),
     start_module_interface(PRODUCER,self),
     begin(self),
     for x in self.made_of
       (//[2] ++++ Compiling the file ~A.cl [v. 3.~A - safety:~A] // x, compiler.version, compiler.safety,
        if (x = string!(self.name))
           Cerror("[211]  ~S cannot be used both as a file and module name",x),
        generate_file((self.source /+ *fs*) /+ x,
                      (compiler.source /+ *fs*) /+ x),
        if false gc()),     // TO REMOVE UGENTLY
     end(self) ]

// This makes the initial loading function by compilinf all the claire
// expression placed in the list oself. *new_objects* holds all the new
// objects defined in this file.
// The name of the function is built from the file name (s argument)
//
[generate_f2f(m:module) : void
 -> let p := fopen(((compiler.source /+ *fs*) /+ string!(m.name)) /+ PRODUCER.extension,
                   "w") in
      (//[0] ==== generate file for module ~S [~A GC protections inserted] ==== // m,PRODUCER.stat,
       OPT.outfile := p,
       generate_file(string!(m.name), m)) ]
       
// v3.2.22 : make this part dependent on the producer
[generate_file(s:string, m:module) : void
 -> start_file(s,m),
    use_as_output(OPT.outfile),
    generate_classes(PRODUCER,s,m),                 // v3.2.44
    for c in list{x in OPT.objects | x % class}     // new in v3.1
       methods_bodies(PRODUCER,c),                  // interface methods
    generate_meta_load(m),
    breakline(),
    printf("GC_UNBIND;"),
    close_block(),
    breakline(),                       // v3.0.3
    fclose(OPT.outfile)]

// ----------------- ClassToFile Mode (FXJ) ----------------------------------------

classFile[c:class] : port := unknown        //  classe ==> port

// prints the definition of classes and their FIELDS (and not slots :-)
[generate_classes(self:module) : void
 -> erase(classFile),
    for c in {c in OPT.objects | c % class}
       (classFile[c] := fopen(compiler.source /+ *fs* /+ c_string(PRODUCER,c.name) /+ PRODUCER.extension,"w"),
        use_as_output(classFile[c]),
        trace(2, "++++ Creating the file ~A.java\n", c_string(PRODUCER,c.name)),
        OPT.level := 0,
        printf("// class file for ~S in module ~S ",c,self), // v0.02
        breakline(), breakline(), breakline(),
        printf("public class ~I extends ~I~I~I~I/* empty constructor by default */~Ipublic ~I() {}~I~I~I/* declaration of fields */~I~I",
               ident(c.name),
               ident(c.superclass.name),
               new_block(),
               breakline(),breakline(),breakline(),
               ident(c.name),
               breakline(),breakline(),breakline(),
               for y:slot in {s in get_indexed(c) | domain!(s) = c}
                  (breakline(),
                   printf("public  ~I ", interface!(psort(y.range))),
                   ident(y.selector.name),
                   princ(";")),
               breakline() ),
        fclose(classFile[c])) ]

// TODO: clean the gc() once CLAIRE is stable
[generate_c2f(self:module) : void
 -> let modulePort := fopen(compiler.source /+ *fs* /+ c_string(PRODUCER,self.name) /+ PRODUCER.extension,"w") in
      (OPT.outfile := modulePort,
       use_as_output(modulePort),
       generate_start_file(PRODUCER,self),
       fclose(modulePort),                                      // <FXJ> : PATCH!
       gc(),
       generate_functions(self),
       gc(),
       modulePort := fopen(compiler.source /+ *fs* /+ c_string(PRODUCER,self.name) /+ PRODUCER.extension,"a"),    // <FXJ> : PATCH!
       use_as_output(modulePort),     // may be changed ....
       OPT.outfile := modulePort,                               // <FXJ> : PATCH!
       OPT.level := 2,
       generate_objects(self),
       use_as_output(stdout),
       gc(),
       use_as_output(modulePort),
       generate_meta_load(self),
       generate_end_file(PRODUCER,self)) ]

// the second part is to generate the interface. l is the list of modules
// that were physically used by the module.
[generate_interface(self:module,l:bag) : void
 -> //[0] ==== Generate inteface (.h) files for module ~S // self,
    use_as_output(OPT.cinterface),
    breakline(),
    generate_interface(PRODUCER,self),      // v3.2.44
    namespace!(PRODUCER,self),
    generate_objects(self),
    module!(PRODUCER,self),
    end_module_interface(PRODUCER,self),
    fclose(OPT.cinterface),
    use_as_output(stdout) ]


// generate the definition of the named objects from the module (used in both modes)
// must move to the producer
[generate_objects(self:module)  : void
 -> for x in OPT.objects      // remove classes
      (breakline(),
       public_static(PRODUCER),
       case x
        (global_variable                                 // v3.3 - new ! native global vars
           printf("~I ~I;",
                  interface!(PRODUCER,(if nativeVar?(x) getRange(x) else global_variable)),
                  ident(x.name)),
         any printf("~I ~I;",
                interface!(PRODUCER,Compile/psort(owner(x))),
                (if (x % class) ( princ("_"),  c_princ(string!(x.name)))
                 else if (x % reserved_keyword)
                   (princ("_cl_"), c_princ(string!(x.name)))
                 else ident(x.name))))),
     for x in {p in OPT.properties | not(p % OPT.objects) }  
       (when p2 := some(p2 in (OPT.properties but x) |            // v0.01
                        string!(p2.name) = string!(x.name)) in
         error("[217] ~S and ~S cannot be defined in the same module",p2,x),
        printf("\n~I~I ~I;// ~S",
               public_static(PRODUCER),
               interface!(PRODUCER,Compile/psort(owner(x))),
               ident(x.name), x.name)) ]



// generate the meta_load function
[generate_meta_load(self:module) : void   // v0.02
  -> printf("// definition of the meta-model for ~S \n~I",self, breakline()),
     generate_meta_load(PRODUCER,self),       // 1st lines are target dependent
     printf("// definition of the properties ",breakline()),
     for x in {p in OPT.properties | not(p % OPT.objects)}
        declare(PRODUCER,x),
     breakline(), breakline(),
     printf("// instructions from module sources",breakline()),
     let j:any := unknown in (
       for i in OPT.instructions (
          breakline(),
          if (i % string)  printf("~I// ~A", (if not(j % string) breakline()), i)
          else if global_var_def?(i) global_var_def!(PRODUCER, self, i as Let) // v3.3
          else  statement(i, {}, {}),
          j := i))]


// v3.3 trap global variable definitions

// pattern matching
[global_var_def?(x:any) : boolean
  -> case x (Let (x.value % Call & x.value.selector = Compile/object! &
                           x.value.args[2] = global_variable),
             any false) ]

[getRange(x:global_variable) : class
  -> (if (x.range = {}) owner(x.value) else class!(x.range)) ]


// generate the body of the methods
[generate_functions(self:module) : void
 -> printf("// definition of class methods "),
    let p := OPT.outfile in
         (for f in OPT.functions
           (OPT.level := 2,
            OPT.outfile := p,
            print_c_function(f[1],f[2],f[3]))) ]      // v0.04 TO CHECK WITH FXJ



// This is a similar method which places all the necessary modules
// in the right order so that self can be defined
parents(self:module,l:list) : list
 -> (if (self % l) l
     else (if known?(part_of, self) l := parents(self.part_of, l),
           l :add self, l))

// this methods takes a list of modules that must be loaded and returns
// a list of modules that are necessary for the definition
//
parents(self:list) : list
 -> (let l := list<module>() in (for x in self l := parents(x, l), l))

// useful (v3.0.06)
[claire/get(m:module) : void ->  load(m), begin(m) ]


// *********************************************************************
// *     Part 3: File compilation                                      *
// *********************************************************************

// this is the basic file cross_compiler, which translates from claire to C
// this file compiler runs only in the good environment (the file
// to be compiled must be already loaded).
// changed ib v0.02 to accomodate F2C mode
[generate_file(self:string,f2:string) : void
 -> let p1 := fopen(self /+ ".cl", "r"), b := reader.Reader/toplevel,
        p0 := reader.Reader/fromp in
       (if not(compiler.class2file?)                 // v0.02
           OPT.outfile := fopen(f2 /+ PRODUCER.extension, "w"),
        reader.Reader/toplevel := false,
        compiler.loading? := true,
        reader.Reader/nb_line := 1,
        reader.external := self,
        reader.Reader/fromp := p1,                     //<yc> ensures automatic fclose !
        if not(compiler.class2file?) start_file(self,module!()),
        let %instruction := Reader/readblock(p1) in
          while not(%instruction = Reader/eof)
            (if (system.verbose > 5)
               printf("[~A] ~S (~S%)\n", reader.Reader/nb_line, owner(%instruction),
                       OPT.need_modules),  
             if (%instruction % string & not(compiler.class2file?))
              (if (compiler.Optimize/naming < 2)
                let pp := use_as_output(OPT.outfile) in
                 (printf("\n//~A", %instruction),
                  use_as_output(pp)))
             else OPT.instructions :add c_code(%instruction, void),
             %instruction := Reader/readblock(p1)),
       fclose(p1),
       compiler.loading? := false,
       reader.Reader/toplevel := b,
       reader.external := "toplevel",
       reader.Reader/fromp := p0,
       if not(compiler.class2file?) fclose(OPT.outfile)) ]



//**********************************************************************
//*     Part 4: the lambda-to-function compiler                        *
//**********************************************************************

// This method creates a C/C++/Java function from a claire lambda.
// The body of the function is obtained by an apporpriate call to the C compiling methods
// m is either unknown/{} for a free lambda, or the method to which the lambda
// is bound.
[make_c_function(self:lambda,%nom:string,m:any) : any
 -> if  compiler.class2file?
        create_function_entry(PRODUCER,self,%nom,m)   // OPT.functions :add list(self,%nom,m)
    else print_c_function(self,%nom,m) ]

// ------------ new version with optimized body generation ------------------------

// this method produced the code associated with a lambda. m is either the
// corresponding method or the range for a free lambda, or nil for a demon
[print_c_function(self:lambda, %nom:string, m:any) : any
 ->  PRODUCER.body := self.body,
     let s := void,
         %body := (if not(m) c_code(self.body, void)
                   else if (m % method) (s := check_sort(m), PRODUCER.body)
                   else if (m % class) (s := (m as class), c_code(self.body,m)) // v0.01
                   else (s := any, c_code(self.body, any))),
         %end := protect_result(PRODUCER, s, OPT.protection, m),
         %debug := need_debug?(m),
         %profile := (OPT.profile? & (m % method | m = unknown))  in    // unknown => demon
       (generate_function_start(PRODUCER, self, s, m, %nom),        // remove one parameter (%f)
        if (OPT.max_vars > 0)
           (*variable_index* := 0,
            lexical_num(%body, length(self.vars) + 1),    //<yc> bug with new var indexes 6/5/98
            OPT.loop_index := *variable_index*),          // better since v3.0.60
        new_block(),
        if %profile generate_profile(PRODUCER,m),
        if %debug debug_intro(PRODUCER,self, m),
        //   [debug] method ~A [loop_gc = ~S]... // %nom,OPT.loop_gc,
        print_body(%body,%end,s,self.body,
                   not(OPT.protection | %profile |%debug | OPT.alloc_stack)),
        close_block(),
        breakline(),
        OPT.alloc_stack := false,
        use_as_output(stdout)) ]

// version for Ifs
[print_body(%body:If,%end:string,s:class,%original:If,%easy:boolean) : void
  -> if (c_func(%body.test) & OPT.protection & c_safe(%original.arg) &
         not(module!() % compiler.debug?))
       let %end2 := (if (s != void) "return " else "") in
       (printf("if ~I ~I~I ~Ielse",
               bool_exp(%body.test, true, nil),
               (breakline(),new_block()),
               outer_statement(%body.arg,%end2,s,%easy),
               close_block()),
        new_block(),
        print_body(%body.other,%end,s,%original.other,%easy),
        close_block())
     else print_body@any(%body,%end,s,%original,%easy)]

[print_body(%body:any,%end:string,s:class,%original:any,%easy:boolean) : void
  -> gc_introduction(PRODUCER,%body),               // v3.0.55
     outer_statement(%body,%end,s,%easy) ]

// special case when the body is a Do
[print_body(%body:Do,%end:string,s:class,%original:any,%easy:boolean) : any
 -> let l := %body.args, %length := length(l), m := 0 in
      (gc_introduction(PRODUCER,%body),        // v3.0.55
       for x in l
        (m :+ 1,
         if (m = %length) outer_statement(x,%end,s,%easy)
         else inner_statement(x, {}, {}))) ]

// prints a return statement - changed in v3.2.44 to take care of ANSI C requiprements
[outer_statement(%body:any, %end:string,s:class, %easy:boolean) : void 
   -> if (c_func(%body) & %easy & (s != void) & not(%body % If)) 
             (if (%end != "") printf("~A(~I);", %end, expression(%body, nil)) 
              else  printf("~I;",expression(%body, nil))) 
      else if (s != void)
            (new_block(),                            //<FXJ> ANSI C 
             define_variable(PRODUCER,s,"Result"), 
             breakline(), 
             statement(%body, "Result", {}), 
             if (%end != "") printf("~A(Result);~I", %end, close_block()))        //<FXJ>  ANSI C
      else (statement(%body, {}, {}),
             princ(%end)) ] 
  
// finds out if no allocation occurs (useful for an if branch)
// only useful when OPT.allocation is raised !
[c_safe(x:any) : boolean
   -> not(OPT.allocation & Optimize/c_status(x,nil)[NEW_ALLOC]) ]          // v3.3.3 !!!

// this is a cute trick   
claire/WrongMethod:any :: 1

// check the range & sort of the method through type inference. Produces the
// optimized code (placed in PRODUCER.body)
[check_sort(self:method) : class
 -> let s1 := self.range, b := PRODUCER.body,
        s2 := Optimize/ptype(c_type(b)), s := psort(s1) in
      (PRODUCER.body := c_strict_code(b, s),                            // includes C++ type checks
       //[5] ---- note: ~S's range was found to be ~S (vs. ~S) // self, s2, s1,
       if not(s2 <= s1)
         (//[2] ---- note: ~S's range was found to be ~S (vs. ~S) // self, s2, s1,
          if (WrongMethod = 0) (WrongMethod := b, error("You can look at WrongMethod")),
          if (compiler.safety < 2 |
                (compiler.safety < 4 & not(sort=(osort(s2), s))))
             PRODUCER.body := c_strict_code(c_check(c_code(b, any), c_code(s1, type)), s),  // OID compiling
          if not(sort=(osort(s2), s))
             (// [2] ---- WARNING: wrong sort [~S] inferred for ~S (was ~S) // osort(s2), self, s,
              if (s != void & (sort!(s2) = void | not(s inherit? sort!(s2))))
                  Cerror("[218] Sort error: Cannot compile ~S.",self))),
        let s3 := (s1 ^ s2) in
          (if (compiler.safety > 1 & osort(s3) = s)
              (PRODUCER.body := c_strict_check(PRODUCER.body, class!(s3)),
               // put(range,self,s3))),
               nil)),
        if (s1 % tuple)
           (//[3] --- note: ~S is a method with range <= tuple => use stack allocation // self,
            OPT.alloc_stack := true),                        // v3.2.26
        if (OPT.allocation & not(status!(self)[SAFE_GC]))
           (// OPT.protection := true,  NOT NECESSARILY -> a verifier <yc> 7/98
            if not(status!(self)[NEW_ALLOC])
               trace(4, "---- note: ~S may provoke an allocation \n", self))
        else (OPT.loop_gc := false,
              OPT.protection := false),
        psort(self.range))]


// prints a list of arguments with types
[typed_args_list(self:list) : any
 -> let prems := true in
       for x:Variable in self
         (if prems prems := false else printf(","),
          interface!(PRODUCER,sort(x)),
          ident(PRODUCER,x)) ]

// tells if a method needs debug instrumentation
[need_debug?(m:any) : boolean
 -> case m
      (method let p := m.selector in
                (m.module! % compiler.debug? &
                 domain!(m) != environment &
                 m.module! != claire & p != self_eval & p != execute &
                 p != eval_message & p != Core/push_debug & p != Core/pop_debug &
                 p != Core/tr_indent & p != Core/find_which & p != Core/matching? &
                 p != Core/vmatch?),
       any false) ]


// computes the inter-module dependence
get_dependents(m:method) : void
  -> (for p in Reader/dependents(m) Reader/PRdependent[m.selector] :add p)


[c_princ(self:function) : void -> c_princ(string!(self)) ]

// add the function for making function later
// decide where to generate the code of the compiled function
// the rule is: if 1st arg is of type a class c declared in that module m
//              or the range is such a class c, the code is produced in the
//              file c.java, otherwise it is generated in m.java
// assumes that the module file is in OPT.outfile
[set_outfile(self:lambda) : void
  ->  let m := module!(), cl:string := string!(m.name), p:port := OPT.outfile,
          %dom := (if self.vars self.vars[1].range else unknown) in
        (if known?(%dom)
          (if exists(c in OPT.objects | c % class & c = %dom)
              cl := c_string(PRODUCER,%dom.name),
           if (cl != string!(module!().name))       // v0.02 get rid of OPT.module!
              p := fopen(compiler.source /+ *fs* /+ cl /+ PRODUCER.extension,"a"),
              OPT.outfile := p),
         true) ]
          //    extfunc_stuff :add string!(%f),  v0.02 -> a changer !
          //    extfunc_stuff :add cl)) ]

// v3.2.06 - some properties may be extended
(put(open,set_outfile,4),
 put(open,inline_exp,4))


// end of file
//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| ocall.cl                                                    |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// ------------------------------------------------------------------
// this is the heart of the CLAIRE optimizer : message to function calls
// ------------------------------------------------------------------

// ******************************************************************
// *  Table of contents                                             *
// *    Part 1: Restruction Binding                                 *
// *    Part 2: Generic c_type & c_code                             *
// *    Part 3: specialized c_code                                  *
// *    Part 4: Method optimizing                                   *
// *    Part 5: inline methods                                      *
// ******************************************************************

// ******************************************************************
// *    Part 1: Restruction Binding                                 *
// ******************************************************************

// if mode = true This method finds the unique property that can be used, if any;
// returns () if no restriction exist, and "ambiguous" if it cannot
// answer.
// if mode = false, we return the union of the matching ranges
ambiguous :: keyword()
[restriction!(self:property,l:list,mode:boolean) : any
 ->  for i in (1 .. length(l)) l[i] := ptype(l[i]),
     restriction!(self.Kernel/definition, l, mode)]

// finds a suitable restriction in lr. Returns a restriction for a match,
// list(r) for a possible match (unique), () for no match and ambiguous
// otherwise
[restriction!(lr:list,l:list,mode:boolean) : any
 ->  //[5] call restriction!(~S,~S) // lr, l,
     let open_required := (class!(l[1]).open = 3),  // NEW (v3.00.30) : open(c) = 3 means that c is an
         rep:any := {} in                           // extensibility node
            (for r:restriction in lr
               (if (not(rep) & tmatch?(l, r.domain))
                   (if mode rep := r else rep := r.range, break(true))
                else if (r.domain ^ l)
                   (if not(mode)
                       (//[5] ~S add ~S // r, r.range,
                        rep :U r.range)
                    else if (compiler.safety <= 3 | rep != {} | open_required)
                       (rep := ambiguous, break(true))
                    else rep := r)),
             //[5] exit de restriction -> ~S // rep,
             rep) ]

// special version for Super, which only looks at methods with domains
// bigger than c
[restriction!(c:class,lr:list,l:list) : any
 ->  if (compiler.safety > 3) l[1] := c ^ l[1],
          for r:restriction in lr
             (if (c Core/<=t r.domain[1])         // <yc> 7:98 thanks to <fl> !!!
                 (if tmatch?(l, r.domain) break(r)
                  else if (r.domain ^ l) break(ambiguous))) ]

// uses a second order type {property + function}
[use_range(self:method,%l:list) : type
 -> if (self.inline? & unknown?(typing,self))
        let lv := self.formula.vars,
            %t:type := any,
            %l2 := list{ v.range | v in lv} in
          (for v in lv put(range, v, %l[v.index + 1]),
           %t := c_type(self.formula.body),
           for v in lv put(range, v, %l2[v.index + 1]),
           if (self.range % type) %t :^ self.range,
           if not(%t)
              Cerror("[207] inline ~S: range ~S is incompatible with ~S (inferred)",
                    self, self.range, c_type(self.formula.body)),
           %t)
     else (//[5] will try to use range type with ~S // %l,
           let f := get(typing, self),
               %l2 := list<type>{ptype(u) | u in %l},
               %t1 := self.range,
               %t2 := ((try case f
                       (lambda apply(f, %l2),
                        property   apply(f,%l2),
                        function apply(f, list{ object | n in (1 .. (length(%l) + 1))},
                                          %l2),
                        any %t1)
                      catch any  (//[0] ~S's 2nd-order type failed on ~S // self,%l,
                                  %t1)) as type) in
            (if (sort=(osort(%t1), osort(%t2)) | self.selector = externC) %t2
             else if sort=(any, osort(%t1))
                Union(Core/t1 = any, Core/t2 = %t2)   // forces the sort and preserves the type
             else %t1)) ]



// ******************************************************************
// *    Part 2: Generic c_type & c_code                             *
// ******************************************************************

// this is the optimizer for messages
// It follows the stucture of the evaluator (self_eval)
// optimize is the distributed compiling method equivalent to the
// evaluation "behave" method
[c_type(self:Call) : type
 ->  if (self.selector = function!) function
     else let s := self.selector,
              l := self.args,
              %type := list{ c_type(x) | x in l} in
       (if (s = safe) %type[1]
        else if (s = externC & length(l) = 2 & l[2] % class) (l[2] as class)
        else if (s = new & l[1] % class) (l[1] as class)
        else if (s = check_in & l[2] % type)   // v3.3.16
          (if (length(l) = 2) sort_abstract!(l[2] as type)
           else (l[2] as type))                 // set or list -> could do better
        else if (s = nth & %type[1] <= array)   // a Call array will be generated
                (if (member(%type[1]) <= float) float else member(%type[1]))       // v3.2.42
        else if (s = @ & l[1] % property)
           let p := l[1] as property,
               c := l[2] in
             (if (c % class & (p @ c) % method) set(p @ c) else any)
        else if (s = get & l[1] % relation)
           let r := l[1] as relation in
             case r
              (property let xs := (r @ class!(%type[2])) in
                          case xs
                           (slot (if (xs.range <= bag & compiler.safety < 3)
                                     class!(l[2].range)
                                  else if (xs.default % xs.range) xs.range
                                  else extends(xs.range)),
                            any r.range),
               table (if (r.default % r.range) r.range
                      else extends(r.range)))
        else let r := restriction!(s, %type, true) in
               case r
                (slot (if (s = instances & l[1] % class)
                          Param(arg = list, params = list(of), args = list(set(l[1])))
                      else r.range),
                 method  use_range(r, %type),
                 any (if not(s.restrictions) selector_psort(self)
                      else if (s.open = 3 | r != ambiguous) sort_abstract!(s.range)
                      else sort_abstract!(restriction!(s, %type, false) as type)))) ]

// this is the optimizer for messages : does not use the sort unless there is a macro
c_code(self:Call) : any -> c_code_call(self,void)

[c_code_call(self:Call,sx:class) : any
 -> //[5] c_code_call(~S)  // self,
    let  s := self.selector, l := self.args  in
      (if (l[1] % global_variable & l[1].range = {} & designated?(l[1].value)) l[1] := l[1].value,  // v3.0.05 CHECK !!
       let m := inline_optimize?(self),          // use of a pattern optimization
           b:boolean := (l[1] % property),
           d := daccess(self, compiler.safety > 5) in
       (if (b & s % {write, put} & length(l) = 3) c_code_write(self)
        else if (b & s = put_store & length(l) = 4 & l[4] = true) c_code_write(self)
        else if (b & s = unknown?) c_code_hold(l[1] as property, l[2], unknown, true)
        else if (b & s = known?) c_code_hold(l[1] as property, l[2], unknown, false)
        else if (b & s = erase & l[2] % Variable) c_code(Produce_erase(l[1],l[2]),sx)
        else if (s = safe)
          let y := compiler.safety, b := compiler.overflow?, x := unknown in
             (compiler.safety := 1, compiler.overflow? := true,     // v3.2.50
              x := Call(safe,list(c_code(l[1], sx))),
              compiler.safety := y, compiler.overflow? := b,
              x)
        else if (s % {add, add!} & b) c_code_add(self)
        else if (s % {add, add!} & c_type(l[1]) <= bag) c_code_add_bag(self)    // v3.0.58 : (b | c_type(l[1]) <= bag))
        else if (b & s = delete) c_code_delete(self)
        else if (s % OPT.to_remove            // v2.4.12 c_interface is special
                | (s = c_interface & length(l) = 2 &
                   not(get_module(s) % OPT.legal_modules))) nil
        else if known?(d) d
        else if (m % method) c_inline(m, l, c_srange(m))
        else if (s % {=, !=} & known?(daccess(l[1], true)))
           c_code_hold(l[1].args[1] as property, l[1].args[2], l[2], s = =)
        else if (s % {=, !=} & known?(daccess(l[2], true)))
           c_code_hold(l[2].args[1] as property, l[2].args[2], l[1], s = =)
        else if (s % {put, nth=} & l[1] % table & length(l) = 3)
           c_code_table(self)
        else if (s % {nth_put, nth=} & c_type(l[1]) <= array & length(l) = 3)
           c_code_array(self)
        else if (s = nth | (s = get & l[1] % table) | (s = nth_get & l[1] % array))
           c_code_nth(self)
        else if (s = %) c_code_belong(self)
        else if (s = Id) c_code(eval(l[1]))
        else if (s = function!)
           make_function(string!(extract_symbol(l[1])))
        else if (s = not & l[1] % Select) c_code_not(l[1])
        else if (s = call & l[1] % property)
           c_code(Call(selector = l[1], args = cdr(l)))
        else if (s.open = 3) c_warn(s, l, list{ c_type(x) | x in l})     // v3.2.04
        else if (s = bit_vector & forall(y in self.args |y % integer)) eval(self)
        else if (s = anyObject! |s = object! | (s = add_method & b)) self
        else let %type := list{ c_type(x) | x in l},
                 z := restriction!(s, %type, true) in
               case z
                (slot let %unknown :=  (not(get(default, z) % z.range) &
                                        not(s % OPT.knowns) & compiler.safety < 5) in
                        (if (not(%unknown) | designated?(l[1])) // v3.1.04
                            Call_slot(selector = z,
                                      arg = c_code(l[1], psort(domain!(z))),
                                      test = %unknown)
                         else (//[3] ---- note: ... unsafe access to unknown slot: ~S // self,
                              if compiler.optimize? (notice(), trace(3,"poorly optimized slot access: ~S\n", self)),  // v3.3
                              c_warn(s,l,%type))),
                 method (//[5] found a method //,
                         if (s = nth=) OPT.use_nth= := true,
                         if (void % %type) Cerror("[205] call ~S uses a void argument [~S]",self,%type), // v3.3
                         // <yc> 7/98 : ensure correct namespaces for further reading
                         if (s % {begin,end} & l[1] % module) eval(self),
                         if (last(z.domain) = listargs |
                             (z.domain[1] = void & l[1] != system))
                            open_message(s, l)
                         else c_code_method(z, l, %type, sx)),
                 keyword c_warn(s, l, %type),    // ambiguous ...
                 any c_warn(self, %type)))) ]     // true error


// create the compiled message with necessary protections
[open_message(self:property,l:list) : Call
 ->  selector_register(self),
     let %arg := list{ (if (c_type(x) != void) c_code(x, any)
                        else Cerror("[206] use of void ~S in ~S~S", x, self, l)) |
                       x in l} in
       (if OPT.allocation %arg := list{ c_gc!(x) | x in %arg},
        if (compiler.diet? & exists(x in l | x % class | x % property))
           (warn(), trace(2,"Non diet call ~S(~A) [254]\n",self,l)),
        Call(self, %arg)) ]


// the gc optimization
[c_gc?(self:Call) : boolean
 -> self.selector = function! |
    (if (self.selector = safe) c_gc?(self.args[1])
     else not((stable?(self.selector) & gcsafe?(self.selector.range)))) ]

// ******************************************************************
// *    Part 3: specialized c_code                                  *
// ******************************************************************

// a get message is special since it represent a direct access. The boolean
// tells if we accept a special form of the unknown value
[daccess(self:any,b:boolean) : any
 -> case self
      (Call let l := self.args,
                xs := (if (self.selector = get & l[1] % property)
                          l[1] @ class!(c_type(l[2]))) in
              (if (case xs
                    (slot (b | xs.default % xs.range | srange(xs) = any |
                           srange(xs) = integer)))
                  Call_slot(selector = xs,
                            arg = c_code(l[2], psort(domain!(xs))),
                            test = false)
               else unknown),
       any unknown) ]

// gc_protection: external MUST NOT be protected
// return true <=> the call_slot must be protected
// note that the part about protecting instances(x) is no longer needed (instances(x) does not change)
// v3.2.28: do not protect a float value (it is native and its coercion will force the protection)
c_gc?(self:Call_slot) : boolean
 -> let s:slot := self.selector,
        x := self.arg in
      ((not(gcsafe?(s.range)) & s.range != float) &         // otherwise no reason to worry !
       (s.selector.open >= 1 | not(gcsafe?(domain!(s)))))

c_type(self:Call_slot) : type -> self.selector.range
c_type(self:Call_table) : type -> self.selector.range
c_type(self:Call_array) : type -> (self.test as type)

// write optimization: ss is put, put_store or write
// note that a put(object,x that may be unknown) is hard to compile !
// v2.4.10 -> if x = unknown OK (o.r = NULL) otherwise use store
[c_code_write(self:Call) : any
 -> let p := self.args[1],
        x := self.args[2],
        y := self.args[3], yt := c_type(y),
        ss := self.selector,
        s := restriction!(p, list(c_type(x)), true) in
       (//[5] c_code_write(~S) // self,
        OPT.use_update := true,
        if (p % OPT.to_remove) nil
        else if (case s
                  (slot (yt <= s.range | compiler.safety >= 4)))
           (if (y != unknown & not(yt ^ srange(s)))
               (//[5] ====> ~S ^ ~S = ~S // yt, srange(s), yt ^ srange(s),
                warn(),trace(2,"sort error in ~S: ~S is a ~S [253]\n",self,y,yt)),
            if ((yt <= s.range | yt <= object | srange(s) != object | y = unknown) &   // v2.4.9 protect put
                (ss != write | (Update?(p, x, y) & (p.multivalued? = false | unknown?(if_write,p)))))   // put or put_store  v3.3
               // MAJOR DECISION in v3.3.20 : allow fast update x.l := l2 for multivalued slots (no inverse  & no demons !)
               let %x := c_code(x, psort(domain!(s))),
                   %y := c_strict_code(y, psort(s.range)) in
                 Update(selector = p, value = %y,
                        arg = (if (ss != write) ss else c_code(x, any)),
                        var = Call_slot(selector = s, arg = %x, test = false))
            else if (ss = put)
              c_code(Call(store, list(x,s.index,srange(s),y,p.Kernel/store?)))
            else (if compiler.diet? (warn(), trace(2,"~S is not a diet call [254]",self)),
                  if (compiler.optimize? & p != instances)
                     (notice(), trace(3,"poorly typed update: ~S\n", self)),  // v3.3
                  c_code(Call(mClaire/update, list(p, x, s.index, srange(s), y)))))
        else let %type := list{ c_type(x) | x in self.args},
                 z := restriction!(ss, %type, true) in
               (//[3] ---- note: ~S is poorly typed (~S,~S) // self, c_type(x), yt,
                case z
                (method c_code_method(z, self.args, %type),
                 any c_warn(self, %type)))) ]

// (get(p,x) =/= y) optimization. We try to use the smart form instead of the get
c_code_hold(p:property,x:any,y:any,b:boolean) : any
 -> let s := restriction!(p, list(c_type(x)), true) in
       (if (case s (slot (y = unknown | (c_type(y) <= srange(s) & identifiable?(y)))))
           let cs := Call_slot(selector = s,
                               arg = c_code(x, psort(domain!(s))),
                               test = false),
               cm := Call_method2(arg = (identical? @ any),
                                  args = list(cs, c_code(y, srange(s)))) in
             (if b c_code(cm)
              else c_code(Call(selector = not, args = list(cm))))
        else let l := list(any, any) in
               c_code_method((if b = else !=) @ l,
                             list(c_code(Call(get,list(p, x)),any), c_code(y, any)),
                             l))

// add optimization
c_code_add(self:Call) : any
 ->   let p := (self.args[1] as property),
          x := self.args[2],
          y := self.args[3],
          s := (p @ class!(ptype(c_type(x)))) in   // WARNING: new in v2.0.60 ! use ptype
       (OPT.use_update := true,
        if (case s
             (slot (c_type(y) <= member(s.range) | compiler.safety >= 4)))
           (if Update?(p,self.selector)       // open for using Update if necessary
               let x2 := c_code(x, psort(domain!(s))) in
                 Update(selector = p,
                        arg = add,            // mark => p multivalued !
                        var = Call_slot(selector = s, arg = x2, test = false),
                        value = c_code(y, psort(member(s.range))))
            else if (designated?(x) &                   // new: add is simple
                       ( not(p.mClaire/store?) &        // direct mode does not handle STORE ?
                         (self.selector = add! |unknown?(inverse, p) )))
               let x2 := c_code(x, psort(domain!(s))) in
                  c_code(Call(add,
                              list(Call_slot(selector = s, arg = x2,
                                             test = false), y)))
            else (if compiler.optimize? (notice(), trace(3,"poorly typed update: ~S\n", self)),  // v3.3
                  c_code_method(add! @ property, list(p, x, s.index, y),
                               list(property, c_type(x), integer,
                                    c_type(y)))))
        else c_code_method(add @ property, self.args, list{ c_type(x) | x in self.args}))


// new in v3.0.59
c_code_add_bag(self:Call) : any
 -> let %t1 := c_type(self.args[1]),  // known to be a subset of bag
        %t2 := ptype(c_type(self.args[2])),  // length is more than 2   v3.3: use ptype !
        %p :=  (if ((%t1 % Param & %t2 <= member(%t1)) | compiler.safety >= 4) add!
                else self.selector),
        %ltype := list(%t1,%t2),
        z := restriction!(%p, %ltype, true) in
     (//[5] ~S: ~S -> ~S // self, %ltype, z,
      if (not(%t2 <= member(%t1)) & self.selector = add)
         (warn(),trace(2,"the bag addition ~S is poorly typed (~S) [251] \n",self,member(%t1))),  // v3.3
      case z
       (method c_code_method(z, self.args, %ltype),
        any c_warn(self, %ltype)))

// delete optimization
// <yc> 7/98 new, also needed
c_code_delete(self:Call) : any
 -> (let p := self.args[1],
         x := self.args[2],
         y := self.args[3],
         s := (p @ class!(c_type(x))) in
       (OPT.use_update := true,
        if (unknown?(inverse, p) & designated?(x) &
            (case s (slot (c_type(y) <= member(s.range) | compiler.safety >= 4))))
          let x2 := c_code(x, psort(domain!(s))) in
               c_code(Call(delete,
                          list(Call_slot(selector = s, arg = x2,
                                         test = false), y)))
                ; Update(selector = p, arg = put,
                ;        var = Call_slot(selector = s, arg = x2, test = false),
                ;        value = c_code(Call(delete,
                ;                            list(Call_slot(selector = s, arg = x2,
                ;                                           test = false), y)),
                ;                       bag))
        else c_code_method(delete @ property, self.args, list{ c_type(x) | x in self.args})))

// cute optimization
c_code_not(x:Select) : any
 -> c_code(Call(not, list(For(var = x.var, set_arg = x.set_arg,
                              arg = If(test = x.arg, arg = Return(arg = true),
                                       other = unknown)))))

// old % optimization
[c_code_belong(self:Call) : any
 ->  let x := self.args[1],
         y := self.args[2],
         %type := list(c_type(y), c_type(x)) in     // watch: permutation !
       (if (y % set)
           Or(args =
                list{ c_code(Call(selector = =, args = list(x, z)), any) |
                  z in y})
        else if (%type[1] <= list)  // v3.3.14     | %type[1] <= tuple)           // v3.2.28
           c_code_method(contain? @ list(list, any), list(y, x), %type)
        else if (%type[1] <= set)
           c_code_method(contain? @ list(set, any), list(y, x), %type)
        else if (y = object)
           c_code_method(% @ list(any, class), list(x, y),
                         list(any, class))
        else member_code(y, x)) ]

// nth optimization for arrays (the selector may also be get)
[c_code_nth(self:Call) : any
 ->  let l := self.args,
         x := l[1], p := self.selector,         // p is nth or get !
         t := c_type(x), mt := member(t),
         r := restriction!(p,list{c_type(u) | u in l}, true) in
       (if (x % OPT.to_remove) nil
        else if ((case x (table x.params % integer)) &
                 (c_type(l[2]) <= x.domain |
                    (p = nth & compiler.safety > 2)))
           Call_table(selector = x, arg = c_code(l[2], integer),
                      test = not((x.default % x.range | x.default = 0 | p = get)))
        else if ((case x (table x.params % list)) & length(l) = 3 &
                 (tuple!(list(c_type(l[2]), c_type(l[3]))) <= x.domain |
                  compiler.safety > 2))
           Call_table(selector = x,
                      arg = List(args =
                        list(c_code(l[2], integer), c_code(l[3], integer))),
                      test = not((x.default % x.range | x.default = 0 | p = get)))
        else if (t <= array & (p = nth_get | compiler.safety > 2) &
                 (mt <= float | (mt ^ float = {})))
           Call_array(selector = c_code(x,array), arg = c_code(l[2], integer),
                      test = mt)
        else if (r % method)
           (if (compiler.optimize? & (t <= array | t <= table))
               (notice(), trace(3,"poorly typed call: ~S\n", self)),  // v3.3
            c_code_method(r, self.args, list{ c_type(x) | x in self.args}))
        else c_warn(p, self.args, list{ c_type(x) | x in self.args})) ]

// nth= optimization for tables
[c_code_table(self:Call) : any
 ->  let sp := self.selector,
         p := (self.args[1] as table),
         x := self.args[2],
         y := self.args[3] in
       (if (p % OPT.to_remove) nil
        else if (sp = put |
                 ((c_type(x) <= p.domain | compiler.safety >= 5) &
                  (c_type(y) <= p.range | compiler.safety >= 4)))
           (if (Update?(p, x, y) & (p.params % list | p.params % integer))
               let %x := c_code(x, any),
                   %y := c_code(y, any) in
                 Update(selector = p, value = %y,
                        arg = (if (sp = put) put else %x),
                        var =
                          Call_table(selector = p, arg = %x, test = false))
            else if (sp = put |
                     (unknown?(inverse, p) & unknown?(Kernel/if_write, p)))
               (if compiler.optimize? (notice(), trace(3,"poorly typed update: ~S\n", self)),  // v3.3
                c_code_method(put @ table, self.args, list(table, any, any)))
            else c_code_method(nth_put @ table, self.args,
                               list(table, any, any)))
        else c_code_method(nth= @ table, self.args, list(table, any, any))) ]

// version for arrays
[c_code_array(self:Call) : any
 ->  let sp := self.selector,
         p := self.args[1], tp := c_type(p), mt := member(tp),
         x := self.args[2], y := self.args[3],
         typeok:boolean := (c_type(y) <= member(tp) | compiler.safety >= 4) in
       (if ((sp = nth_put | typeok) & (mt <= float | (mt ^ float = {})))
           let %x := c_code(x, integer),
               %y := c_code(y, (if (mt <= float) float else any)) in  // v2.4.03
                 Update(selector = p, value = %y,
                        arg = put,
                        var = Call_array(selector = c_code(p,array), arg = %x, test = mt))
        else (if compiler.optimize? (notice(), trace(3,"poorly typed update: ~S\n", self)),  // v3.3
              c_code_method( ((if typeok nth_put else sp) @ array),
                            self.args, list(tp, any, any)))) ]

// can we use the special UDATE form ?
[Update?(p:relation,x:any,y:any) : boolean
 -> (p != inverse) &
    ( (known?(Kernel/if_write, p) & not(p.if_write % list)) |
      ( unknown?(inverse, p) &              // MAJOR DECISION IN V3.0.42 : remove not(multi?(p))
        (case p (table p.params % integer, any true)) &
        (if (p.Kernel/store?)
            (designated?(x) & designated?(y) & not(multi?(p)) &
              (identifiable?(y) | c_type(y) <= float))          // v3.2.56: float is ok (STOREF macro)
         else true))) ]

// we do not use an Update form for add
[Update?(p:relation,s:relation) : boolean
   -> known?(if_write,p) & not(p.if_write % list) & s = add ]

// Update returns the value .. <yc:0.01 -> needed in CLAIRE 2.4 !!!>
c_type(self:Update) : type  -> void


// ******************************************************************
// *    Part 3: Method optimizer                                    *
// ******************************************************************

// a basic method is assumed to be compiled if it is in the right module
c_code_method(self:method,l:list,%type:list) : any
 -> c_code_method(self,l,%type,c_srange(self))

c_code_method(self:method,l:list,%type:list,sx:class) : any
 -> (if (self.module! != claire | compiler.safety > 4 |
         known?(functional, self))
        let ld := self.domain,
            n := length(ld) in
          (if (n != length(l))
              l := list{ l[i] | i in (1 .. (n - 1))} add
                   list{ l[i] | i in (n .. length(l))},
           if (self.inline? & c_inline?(self, l))
              c_inline(self, l, sx)
           else let b := OPT.allocation, x:any := nil in
                  (write(allocation, OPT, false),
                   x := Call_method!(self,
                                     list{ c_strict_code(l[i], psort(ld[i])) |
                                           i in (1 .. n)}),
                   if not(OPT.allocation) OPT.allocation := b,
                   x))
     else (if compiler.optimize? (notice(), trace(3,"poorly typed update: ~S\n", self)),  // v3.3
           open_message(self.selector, l)))

// the code to be produced for a method
// SAFE_GC => do not protect the arguments
Call_method!(self:method,%code:list) : any
 -> (if (status!(self)[NEW_ALLOC])
        (OPT.allocation := true,
         if not(self.status[SAFE_GC]) %code := list{ c_gc!(x) | x in %code})
     else if (OPT.allocation &
              length(list{ x in %code | c_gc?(x)}) > 1)
        %code := list{ c_gc!(x) | x in %code},
    // if (self.range = float) OPT.protection := true,    // <yc> 3/10/98 NOT optimal but OK
     if (self.status[BAG_UPDATE]) OPT.use_nth= := true,
     if (self.status[STRING_UPDATE]) OPT.use_string_update := true,  // v3.3.46
     if (self.status[SLOT_UPDATE]) OPT.use_update := true,
     if not(legal?(self.module!, self))
        trace(0,"in call ~S~S\n",self.selector,%code),
     if (length(%code) = 1) Call_method1(arg = self, args = %code)
     else if (length(%code) = 2) Call_method2(arg = self, args = %code)
     else Call_method(arg = self, args = %code))


// a call_method or a call external has an obvious type (we do not need to do
// better ?)
//
c_type(self:Call_method) : type
 -> use_range(self.arg, list{ c_type(x) | x in self.args})

// a call_method is already compiled
c_code(self:Call_method) : any -> self

// gc protection of the result
//   either the status is on, or we received a dangerous argument as a parameter.
// SAFE_GC is set by hand when the result is already protected by the called method
// note that a float call is safe: either it is native, or the value is passed through a
// call to _float_ that already protects the result
c_gc?(self:Call_method) : boolean
 -> (let m := self.arg in
       ((not(gcsafe?(m.range)) & m.range != float) &     // v3.2.28
        ( not(status!(m)[SAFE_RESULT]) |
          not(m.range <= bag & OPT.loop_gc)) &           // v3.2.32 : in a loop SAFE-RESULT may be wrong
        ( not(status!(m)[RETURN_ARG]) |                   // v3.4  RETURN_ARG is an optim : not there => result as expected
          (status!(m)[NEW_ALLOC] | exists( x in self.args | c_gc?(x)))))) // if RETURN_ARG, then gc-protect only if alloc
// was       (status!(m)[NEW_ALLOC] |
//             (m.status[RETURN_ARG] & exists( x in self.args | c_gc?(x))))))

// NOTE (3.4) forcing to true when NEW_ALLOC (& RETURN_ARG) is strange, but RETURN_ARG is currently wrong !
    
// gets the associated function if it exists and create one otherwise
Compile/functional! :: property(open = 3)
[functional!(self:method) : function
 ->  let f := get(functional, self),
         p := self.selector in
       case f (function f,
               any make_function(function_name(p, self.domain, f))) ]

// second-order types for better safety or optimization -------------------------------
[nth_type_check(tl:type,ti:type,tx:type) : any
  =>  if not(tx <= member(tl))
         (warn(), trace(2,"unsafe update on bag: type ~S into ~S [252]\n", tx,tl)),
      tx ]
(write(typing, nth= @ list, nth_type_check))

// ******************************************************************
// *    Part 5: inline methods                                      *
// ******************************************************************

// macro expansion for inline method ?
// we check that it is a good idea
[c_inline?(self:method,l:list) : boolean
 -> let f := self.formula, la := f.vars, x := f.body, n := 1 in
       not((for v in f.vars
              (if (Language/occurrence(x, v) > 1 &
                   not(designated?(l[n])) & not(v.range % Pattern))
                  break(true)
               else n :+ 1))) ]

// checks if a special optization restriction can be used (with patterns)
[inline_optimize?(self:Call) : any
 -> let l := self.args,
        m := restriction!(self.selector, list{ set(x) | x in l}, true) in
       case m
        (method (if (m.inline? & exists(s in m.domain | s % Pattern) 
                     & c_inline?(m, l)) m),
         any false) ]


// eof
//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| ocontrol.cl                                                 |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+


// *********************************************************************
// * Contents                                                          *
// *     Part 1: Basic Instructions                                    *
// *     Part 2: other control structures                              *
// *     Part 3: If, Case, Do, Let                                     *
// *     Part 4: Loops                                                 *
// *     Part 5: Iterate                                               *
// *********************************************************************


// *********************************************************************
// *      Part 1: Basic Instructions                                   *
// *********************************************************************

// the type of an assignment is the type of the result
[c_type(self:Assign) : type -> c_type(self.arg)]

// we must include the type checking if needed
[c_code(self:Assign) : any
 ->  let v := self.var,
         x := self.arg,
         %type := ptype(c_type(x)) in
       (if not(v % Variable) Cerror("[213] ~S is not a variable", v),
        if not(%type Core/<=t v.range) x := c_warn(self.var, x, %type),
        let %arg := c_gc!(c_strict_code(x, psort(v.range)), v.range ^ %type) in
          (gc_register(v,%arg),                 // v3.1.06
           Assign(var = v, arg = %arg)))  ]

[c_gc?(self:Assign) : boolean -> c_gc?(self.arg)]

// assignment to a global variable
[c_type(self:Gassign) : type -> c_type(get(arg, self)) ]
[c_code(self:Gassign) : any
 ->  let %v := get(arg, self),
         %type := ptype(c_type(%v)) in
       (if not(self.var.range) Cerror("[214] cannot assign ~S", self),
        if not(%type Core/<=t self.var.range)
           %v := c_check(c_code(%v, any), c_code(self.var.range, type)),
        Gassign(var = c_code(self.var),
                arg = (if nativeVar?(self.var)
                          c_strict_code(%v, psort(self.var.range))
                       else c_code(%v, any)))) ] // v3.3 !

[c_gc?(self:Gassign) : boolean -> c_gc?(self.arg)]

// _______________ l AND/OR     ____________________________________

[c_type(self:And) : type -> boolean]
[c_code(self:And) : any
 -> And(args =
          list{ (if (c_type(x) = void) Cerror("[206] void ~S in ~S", x, self),
                 c_boolean(x)) |
                 x in self.args}) ]

[c_type(self:Or) : type -> boolean]
[c_code(self:Or) : any
 -> Or(args =
         list{ (if (c_type(x) = void) Cerror("[206] void ~S in ~S", x, self),
                c_boolean(x)) |
                x in self.args})]

//---------------- quote and return -------------------------------------
[c_type(self:Quote) : type -> owner(self.arg)]
[c_code(self:Quote) : {}
 -> Cerror("[internal] optimization of quote not implemented yet! ~S",self)]

// a to_protect is a wrapper
c_type(self:to_protect) : type -> c_type(self.arg) // <yc> can be string
c_code(self:to_protect) : any -> self
c_gc?(self:to_protect) : boolean -> false


c_type(self:Return) : type -> any
c_code(self:Return) : any
  ->  (OPT.loop_gc := false,             // v3.3.36: LOOP_GC optimization is unsafe in the presence of a break :-(
       Return(arg = c_code(self.arg , any)))

// optimisation of exception handlers
[c_type(self:Handle) : type -> (c_type(self.arg) U c_type(self.other))]

[c_code(self:Handle,s:class) : any
 ->  let x := Handle(test = any, arg = c_code(self.arg, s),
                     other = c_code(self.other, s)) in
       (if (self.test != contradiction)
           write(allocation, OPT, true),
        put(test, x, self.test),
        x) ]

c_gc?(self:Handle) : boolean
 -> (c_gc?(self.arg) | c_gc?(self.other))

// ****************************************************************
// *      Part 2: Specific structures                             *
// ****************************************************************

// __________________ CAST ________________________________________

// cast is now more subtle since we introduce coercion for list<t> types
[c_type(self:Cast) : type -> self.set_arg]

[c_code(self:Cast) : any
 -> let y := self.set_arg, ftype := psort(y) in
      (if (case y (Param ((y.arg = list | y.arg = set) & y.args[1] % set)))
        let utype := ((y as Param).args[1] as set)[1] in
            (if (c_type(self.arg) @ of = utype | compiler.safety > 4) c_code(self.arg, ftype)
             else  c_code( Call(Core/check_in,
                                list(self.arg,(y as Param).arg, utype)),
                           ftype))
       else (if (c_type(self.arg) <= y | compiler.safety > 1) 
                c_code(self.arg, ftype)
             else c_code(Call(Core/check_in,               // v3.3.16 - type check for as 
                              list(self.arg,y)),ftype))) ]


// _________________ SUPER _________________________________________
c_type(self:Super) : type
 -> (let %type := list{ c_type(x) | x in self.args},
         s := self.selector in
       (%type[1] := self.cast_to,         // <yc> 7/98
        let prop := (if (s.open = 3) nil
                     else restriction!(class!(self.cast_to), 
                                       s.Kernel/definition, %type)) in
          case prop
           (slot prop.range,
            method use_range(prop, %type),
            any s.range)))

// this is the optimizer for messages
c_code(self:Super) : any
 -> (let s := self.selector, l := self.args,
         %type := list{ c_type(x) | x in self.args},
         prop := (if (s.open = 3) nil
                  else  restriction!(class!(self.cast_to), 
                                     s.Kernel/definition, %type)) in
       case prop
        (slot Call_slot(selector = prop,
                        arg = c_code(l[1], psort(domain!(prop))),
                        test = (not(get(default, prop) % prop.range) & compiler.safety < 5)),
         method c_code_method(prop, l, %type),
         any c_warn(self, %type)))

// we will need this direct call for compiling call to CLAIRE_demons
Call_function2 <: Optimized_instruction(arg:function,args:list)

self_print(self:Call_function2) : void
 -> printf("~S(~I)", self.arg, princ(self.args))

c_type(self:Call_function2) : type -> any

c_code(self:Call_function2) : any
 -> Call_function2(arg = self.arg,  args = list{ c_code(x, any) | x in self.args})

// ASSERT & trace
[c_code(self:Assert) : any
 ->  if OPT.online? self
     else if (compiler.safety = 0 | compiler.debug?)
        c_code(If(test = Call(not, list(self.args[1])),
                  arg = Call( Core/tformat,
                              list("Assertion violation in ~A line ~A\n", 0,
                                    List(args = list(self.external, self.index)))),
                  other = false),
               any) ]

[c_code(self:Trace) : any
 -> let a := self.args in
       (if OPT.online? self
        else if (length(a) = 1 & c_type(a[1]) <= integer)
          c_code(Call(write,list(verbose,system,a[1])))
        else if (length(a) > 1 & a[2] % string &
                 (compiler.debug? | (try eval(a[1]) <= system.verbose catch any true)))
           let %c := Call(Core/tformat,
                          list(a[2], a[1], List(args = (copy(a) << 2)))) in
             c_code((if not(a[1] % integer)
                        If(test = Call(<=, list(a[1], Call(verbose, list(system)))),
                           arg = %c, other = false)
                     else %c),
                    any)) ]

c_type(self:Assert) : type -> any
c_type(self:Trace) : type -> any
c_type(self:Branch) : type -> boolean

[c_code(self:Branch) : any
 -> c_code(Handle(arg = Do(list(Call(choice, list(system)),
                                If(test = self.args[1], arg = true,
                                   other = Do(list(Call(backtrack, list(system)),
                                              false))))),
                  test = contradiction,
                  other = Do(list(Call(backtrack, list(system)), false))),any) ]

[c_code(self:Macro,s:class) : any -> c_code(call(macroexpand,self),s)]

[c_type(self:Macro) : type -> c_type(call(macroexpand,self))]


c_type(self:Printf) : type -> any

[c_code(self:Printf) : any
 ->  let l := self.args in
       (if not(l[1] % string)
           Cerror("[209] the first argument in ~S must be a string", self)
        else let s := (l[1] as string),
                 i := 1,
                 n := get(s, '~'),
                 r := list<any>() in
               (while not(n = 0)
                  let m := s[n + 1] in
                    (if (i < length(l)) i :+ 1
                     else Cerror("[210] not enough arguments in ~S", self),
                     if (n > 1)
                        r :add Call(princ, list(substring(s, 1, n - 1))),
                     r :add
                       (if ('A' = m)  Call(princ, list(l[i]))
                        else if ('S' = m) Call(print, list(l[i]))
                        else if ('F' = m)  // v3.4
                            let p% := false,                                    // print a % float ?
                                j := integer!(nth_get(s,n + 2,n + 2)) - 48 in   // an <int> after ~F
                          (if ('%' = s[n + 2]) (p% := true, j := 1)             // ~F% format
                           else if (j < 0 | j > 9) error("[189] F requires a single digit integer in ~S",self),
                           if (not(p%) & '%' = s[n + 3]) (p% := true, n :+ 1),  // ~Fi% format
                           n :+ 1,
                           Call(mClaire/printFDigit,list((if p% Call(*,list(l[i],100.0)) else l[i]),j)))
                        else if ('I' = m) l[i]),
                     s := substring(s, n + 2, 1000),
                     n := get(s, '~')),
                if s r :add Call(princ, list(s)),
                c_code(Do(r), any))) ]


c_type(self:Error) : type -> {}
[c_code(self:Error) : any
 -> let x := OPT.allocation,
        y := c_code(Call(close,
                list(Cast(arg = Call(anyObject!,
                                     list(general_error,
                                          c_code(car(self.args),any),
                                          c_code((if (length(self.args) != 1)
                                                   List(args = cdr(self.args))
                                                  else nil), any))),
                          set_arg = exception))),
                     void) in
         (OPT.allocation := x,  // v3.2.24 -> error => no GC protection is needed !
          y) ]


// *********************************************************************
// *     Part 3: If, Case, Do, Let                                     *
// *********************************************************************

//_______________ IF __________________________________________

// check if the test is of the form known?(v) so that the type (result) can be reduced
[extendedTest?(self:If) : type
 -> let %t := self.test in
      (case %t
        (Call (if (%t.args[1] % Variable & %t.selector = known?)
                  %t.args[1].range
               else any),
         any any))]

// notice that we analyze the test to detect the know? filter
[c_type(self:If) : type
 ->  let %r := extendedTest?(self) in
       (if extended?(%r) range_sets(self.test.args[1], sort_abstract!(%r.Core/t1)),
        let result := (c_type(get(arg, self)) U c_type(get(other, self))) in
          (if extended?(%r) put(range, self.test.args[1], %r), result)) ]

claire/PENIBLE:boolean :: false

[c_code(self:If,s:class) : any
 -> let %r := extendedTest?(self) in
       (if extended?(%r) range_sets(self.test.args[1], sort_abstract!(%r.Core/t1)),
        if ( not(ptype(c_type(self.test)) <= boolean) & (PENIBLE = true))
          (warn(), trace(2,"CLAIRE 3.3 SYNTAX - Test in ~S should be a boolean [260]\n",self)),               // v3.3
        let result := If(test = c_boolean(self.test),
                         arg = c_code(get(arg, self), s),
                         other = c_code(get(other, self), s)) in
          (if extended?(%r) put(range, self.test.args[1], %r), result)) ]

Compile/c_gc?(self:If) : boolean
 -> (c_gc?(get(arg, self)) | c_gc?(get(other, self)))

// ------------------ CASE -------------------------------------------

// a member-of is a CLAIRE case. [yc 1/29/98]
// note that type inference supposes that the case is "closed" (all types are delt with)
// but only with safety >= 5
[c_type(self:Case) : type
 ->  let %var := self.var,
         %type := (case %var (Variable get(range, %var), any any)),  // input type
         l := copy(self.args),
         rtype:type := {},
         utype:type := {} in    // union of all covered cases
       (while (length(l) > 0)
          (if (l[1] % type) (utype :U l[1],
                             if (osort(%type) = osort(l[1])) range_sets(%var, l[1]) // v3.3.0
                             else if (osort(%type) = any)      // v3.3.0
                               range_sets(%var, sort_abstract!(l[1])))
           else Cerror("[208] wrong type declaration for case: ~S in ~S",
                      car(l), self),
           rtype :U c_type(l[2]),
           //[5] so far rtype -> ~S because of ~S branch // rtype, l[1],
           case %var (Variable put(range, %var, %type)),
           l :<< 2),
        if (%type <= utype) rtype   // used to check safety
        else if (rtype <= boolean) boolean  // new: supports open cases
        else any) ]                 // safety

// member_of is treated like a macro and vanishes into a large if.
// the last line is a trap for code generated by the logic compiler.
// [yc 1/29/99]
[c_code(self:Case,s:class) : any
 -> let %var := self.var,
         %type := (case %var (Variable get(range, %var), any any)),
         l := copy(self.args), utype:any := {},
         ctest1 := c_boolean(Call( %, list(%var, l[1]))) in  // new in v3.0.54
       (range_sets(%var, l[1]),
        let rep := If(test = ctest1,
                      arg = c_code(l[2], s),
                      other = c_code(false, s)),
            pointer:If := rep in
          (case %var (Variable put(range, %var, %type)),
           l :<< 2,
           while (length(l) > 0)
             (utype :U l[1],
              if (%type <= utype)
                (if (osort(%type) = osort(l[1])) range_sets(%var, l[1])   // v3.3.0
                 else if (osort(%type) = any) range_sets(%var, sort_abstract!(l[1])), // v3.3.0
                 write(other, pointer, c_code(l[2], s)),
                 case %var (Variable put(range, %var, %type)),
                 break())
              else let ctest := c_boolean(Call(%, list(%var, l[1]))) in
                   (range_sets(%var, l[1]),
                    write(other, pointer,
                          If(test = ctest,  // <yc> new in v0.15
                             arg = c_code(l[2], s),
                             other = c_code(false,s))),
                    pointer := pointer.other as If),
              case %var (Variable put(range, %var, %type)),
              l :<< 2),
           if (case %var (Definition %var.arg % exception)) %var
           else rep)) ]

//_____________________ Block structure________________________
c_type(self:Do) : type -> c_type(last(self.args))

[c_code(self:Do,s:class) : any
 -> Do( (let m := length(self.args), n := 0 in
          list{ (n :+ 1, c_code(x, (if (n = m) s else void))) | x in self.args})) ]

Compile/c_gc?(self:Do) : boolean -> c_gc?(last(self.args))

// ----------------------- LET -----------------------------------

// we make a range inference
//
[c_type(self:Let) : type
 -> range_infers(self.var, c_type(get(value, self))),
    c_type(self.arg) ]

// works also for Let+ / Let*
c_code(self:Let,s:class) : any
 -> (let %v := get(value, self),
         %type:type := ptype(c_type(%v)) in
       (range_infers(self.var, %type),
        if not(%type <= self.var.range) %v := c_warn(self.var, %v, %type),
        let x := Let(var = self.var,
                     value = c_gc!(c_strict_code(%v, psort(self.var.range)), %type),
                     arg = c_code(self.arg, s)) in
          (put(isa, x, self.isa),
           if (x % Let* & %type % tuple & c_status(self.value,nil)[NEW_ALLOC])            // v3.3.3 protection of tuple vars
              let i := 1, z := x.arg in
                 (while (z % Let & i <= length(%type)) 
                        (if not(gcsafe?(%type[i]) | z.value % to_protect)     // need to protect the var since the tuple is short-lived !
                           (OPT.protection := true,
                            z.value := to_protect(arg = z.value)),
                         i :+ 1, z := z.arg)),
           x)))

// type inference for When is more subtle
c_type(self:When) : type
 -> (let %v := get(value, self),
         v := self.var,
         d:any := daccess(%v, true),
         %type := (if known?(d) c_type(d) else c_type(%v)) in
       (if extended?(%type) %type := %type.Core/t1,
        range_infers(v, %type),
        c_type(self.arg) U c_type(self.other)))

// A When is macroexpanded into one/two Let
c_code(self:When,s:class) : any
 -> (let %v := get(value, self),
         v := self.var,
         d:any := daccess(%v, true),
         v2 := Variable!(self.var.pname /+ "test", self.var.index, any),
         %type := (if known?(d) c_type(d) else c_type(%v)) in
       (if extended?(%type) %type := %type.Core/t1,
        range_infers(v, %type),
        if (known?(d) & not(extended?(d.selector.range)))  // <yc> 7/98 : extended(range) =>
           Let(var = v, value = c_gc!(d, %type),           // poss. sort error with direct Let
               arg =
                 If(test =
                      Call_method2(arg = (identical? @ any),
                                   args = list(v, c_code(unknown, c_sort(v)))),
                    arg = c_code(self.other, s),
                    other = c_code(self.arg, s)))
        else if (c_sort(v) = any & %type <= v.range &      // make sure direct let is sort-safe
                 compiler.safety >= 3)                   // v3.0.52
             c_code(Let(var = v, value = %v,
                        arg = If(test =  Call(!=, list(v, unknown)),
                                 arg = self.arg, other = self.other)),
                  s)
        else c_code(Let(var = v2, value = %v,            // double let for safety
                        arg =
                          If(test = Call(!=, list(v2, unknown)),
                             arg = Let(var = v,
                                       value = Cast(arg = v2, set_arg = %type),
                                       arg = self.arg),
                             other = c_code(self.other, s))),
                    s)))

Compile/c_gc?(self:Let) : boolean -> c_gc?(self.arg)

// *********************************************************************
// *     Part 4: Loops                                                 *
// *********************************************************************

// here we could do a return extraction
c_type(self:For) : type -> infers_from(return_type(self.arg),self)

infers_from(t:type,self:any) : type
 -> (if (t = {})     sort_abstract!(boolean)    // will return false
     else if (compiler.safety > 3)
         (//[2] ... c_type(~S) -> ~S - ~S // self,t,sort_abstract!(t),
          sort_abstract!(t))
     else any)        // false or the return value


// notice that for is of sort any and may require a cast ..
[c_code(self:For,s:class) : any
 -> let sx := self.set_arg,
        b := OPT.protection,
        ns := compiler.safety,
        vold := self.var,               // new in v2.5.44 vold => v !
        v := Variable(pname = vold.pname, range = vold.range,
                      mClaire/index = vold.mClaire/index),
        narg := substitution(self.arg,vold,v),
        scs := c_inline_arg?(sx) in
     (OPT.protection := false,
      case sx
         (global_variable
            (if not(sx.range)
                (// the set is a constant ! we replace it by its value to benefit from Iterate optim
                 put(set_arg, self, sx.value), sx := sx.value)),
          Select let %t := c_type(sx) in
                   (if (not(%t <= bag) | %t <= set)
                       (self := copy(self), put(isa, self, Select))),
          class (if (sx.open <= 1 & not(sx.subclass))
                   put(set_arg, self,
                       Call(selector = instances, args = list(sx))))),
        let %t := c_type(self.set_arg),
            %t2 := pmember(%t),
            %t3 := pmember(c_type(Call(selector = set!, args = list(sx)))) in
          (if (%t3 <= %t2) %t2 := %t3,
           range_infers_for(v, %t2,%t),
           write(safety, compiler, 1),
           %t2 := v.range,
           put(range, v, ptype(%t2)),
           let m := Iterate!(self) in
             (if not(m % method)
                 let m2 := restriction!(iterate, list(%t, set(v), any), true) in
                   case m2 (method m := m2),
              write(safety, compiler, ns),
              put(range, v, %t2),
              let r := (if (case m (method m.inline?))
                          (if (compiler.safety < 6 & c_status(narg,nil)[NEW_ALLOC])
                               OPT.loop_gc := true,
                           // this is new in v2.4.06
                           //[5] iteration found -> ~S // m,
                           if sort_abstract?(v.range)
                              put(range,v,Core/t2(v.range)),
                           c_inline(m, list(Language/instruction_copy(self.set_arg), // v3.2.01
                                            v, narg), s))
                        else if scs
                           c_code(For(var = v, set_arg = scs, arg = narg), s)
                        else if (case sx (Call sx.selector = Id))
                            c_code_multiple(self,%t,s)       // new in v3.1.0
                        else let r2 :=
                             For(var = v,
                                 set_arg = c_gc!(enumerate_code(self.set_arg, %t)),
                                 arg = c_code(narg, void)) in
                              (if (s = any) r2 else to_C(arg = r2, set_arg = s))) in
                (if (OPT.protection & OPT.loop_index >= 0 &
                     compiler.safety < 6) OPT.loop_gc := true,
                 OPT.protection := (OPT.protection | b),
                 r)))) ]


// new: we macroexpand the iteration  based on the type
// this is only called if the set is wrapped in an Id
[c_code_multiple(self:For,%t:type,s:class) : any
  -> let v := self.var,
         sx := (self.set_arg as Call).args[1],
         v2 :=  Variable!(v.pname /+ "test", self.var.index, %t),
         n :=  Let(var = v2,
                   value = sx,
                   arg = For(var = self.var, set_arg = enumerate_code(sx, %t), arg = self.arg)) in
       (//[0] ---- note: use an expended iteration for {~S} // self,
        for r in {r in iterate.restrictions |
                   domain!(r) Core/<=t %t & domain!(r) Core/<=t collection & r.inline? &
                   v % r.domain[2] }                 // check var subtyping
         let vnew := Variable(pname = v.pname, range = v.range, mClaire/index = v.mClaire/index),
             narg := substitution(self.arg,v,vnew) in        // a separate var
          n.arg := If(test = Call(%,list(v2,r.domain[1])),   // v3.2.16 domain! => class !
                      arg = (if (compiler.safety < 6 & c_status(self.arg,nil)[NEW_ALLOC])
                                 OPT.loop_gc := true,
                             if sort_abstract?(vnew.range) put(range,vnew,Core/t2(v.range)),
                             c_inline(r, list(v2, vnew, narg), s)),
                      other = n.arg),
        c_code(n,s)) ]


Compile/c_gc?(self:Iteration) : boolean -> true

// ------------------------ Collect/ Image / Select / Lselect ------------------------------

// an Iteration builds a bag
[c_type(self:Iteration) : type
 -> let %t := c_type(self.set_arg) in
     (range_infers_for(self.var, pmember(%t),%t),
      if known?(of,self) Core/param!( (if (self % (Select U Image)) set else list), self.of)
       else nth( (if (self % (Select U Image)) set else list),
                 (if (self % (Select U Lselect))
                     pmember(c_type(self.set_arg))
                  else ptype(c_type(self.arg))))) ]

// They are all expended into a For except for Collect(bag)
c_code(self:Iteration) : any
 -> let sx := self.set_arg,
        %t := c_type(sx) in
      (if (self % For) c_code(self, any)
       else if (case self (Collect %t <= bag))
          (// we generate a Collect ONLY FOR BAGS (thus, not a method)
           write(allocation, OPT, true),
           range_infers_for(self.var, pmember(%t), %t),
           let ty := ptype(c_type(self.arg)),                  // v3.3
               x := Collect(var = self.var,
                            set_arg = c_gc!(c_strict_code(sx, bag)),
                            arg = c_code(self.arg, any)) in
             (if (ty = void) Cerror("[205] use of void expression ~S in ~S",self.arg,self),
              if known?(of,self)
               (if (compiler.safety > 4 | ty <= self.of)     // v3.2.12
                   (x.of := self.of, x)    // type safe !
                else (warn(),
                      trace(2,"unsafe typed collect (~S): ~S not in ~S [261]\n",
                              self, c_type(self.arg), self.of),
                      c_code( Call(Core/check_in,list(x,list,self.of)), list)))
             else x))
       else let  val:any := (if (self % Image) set() else list()),
                 v := Variable!(self.var.pname /+ "_bag",
                                       (OPT.max_vars :+ 1, 0),
                                       (if (self % Image) set else list)) in
              (// If self is a typed construct _<X>{...}, take X into account!
               //[5] (~S:~S) v = ~S range = ~S (arg:~S)// self, self.isa, self.var, self.var.range,self.arg,
               if known?(of,self)
                 let %typeIn := c_type(self.arg) in
                  (if (not(ptype(%typeIn) <= self.of) & compiler.safety <= 4)
                      (warn(),
                       trace(2,"unsafe bag construction (~S) : a ~S is not a ~S [262]\n",
                               self.var, %typeIn, self.of)),
                   cast!(val,of(self)),                       // v3.1.06
                   put(range,v, Core/param!(v.range,self.of)))
               else (val := (if (val % set) Set(of = {}) else List(of = {}))), // v3.2
               Let(var = v,
                   value = val,  // v0.01
                   arg = Do( list(c_code(For(var = self.var, set_arg = sx,
                                          arg = Call(add!,list(v, self.arg))), // v3.1.06
                                         any),
                              (if not(OPT.online?)
                                  (write(protection, OPT, true),
                                   to_protect(arg = v))
                               else v))))))

// new in v3.1.16
// selection has its own optimization method that takes care of the polymorphism
[c_code(self:Select) : any -> c_code_select(self,set) ]                               
[c_code(self:Lselect) : any -> c_code_select(self,list) ] 

[c_code_select(self:Iteration,x:class) : any
 -> let sx := self.set_arg,
        %t := c_type(sx),
        st := enumerate_code(sx, %t),
        val := (if (x = set) set() else list()),   // v3.2
        v1 := Variable!(self.var.pname /+ "_in", (OPT.max_vars :+ 1, 0), bag),
        v2 := Variable!(self.var.pname /+ "_out", (OPT.max_vars :+ 1, 0), x) in
    (// If self is a typed construct _<X>{...}, take X into account!
     if known?(of,self)
       let  %typeIn := pmember(%t) in
          (if (not(ptype(%typeIn) <= self.of) & compiler.safety <= 4)
             (warn(),
              trace(2,"unsafe bag construction (~S) : a ~S is not a ~S [262]\n",
                    self.var, %typeIn, self.of)),
           cast!(val,self.of),                       // v3.1.06
           put(range,v2, Core/param!(x,self.of)),
           inner_select(self,v2,sx,val))             // v3.2.01 ??
      else if (%t <= x)                              // we want to conserve the type of
         Let(var = v1,                               // the input
             value = st,
             arg = inner_select(self,v2,v1,
                              C_cast(arg = c_code(Call(empty,list(v1)),bag), set_arg = x)))
      else inner_select(self,v2,sx, (if (x = set) Set(of = {})
                                     else List(of = {})))) ]  // v3.2.01
                                    
 
// sub-procedure 
[inner_select(self:Iteration,v2:any,sx:any,val:any) : any
 -> Let(var = v2,
        value = val,  // v0.01
        arg = Do( list(c_code(For(var = self.var, set_arg = sx,
                                  arg = If(test = self.arg,           // 
                                           arg = Call(add!, list(v2, self.var)))),
                              any),
                  (if not(OPT.online?)
                      (write(protection, OPT, true),
                       to_protect(arg = v2))
                   else v2)))) ]
   
// if (other = unknown : some) the result is either the variable or unknown
c_type(self:Exists) : type
 -> let %t := c_type(self.set_arg) in
     (range_infers_for(self.var, pmember(%t),%t),
      if (self.other = unknown) extends(pmember(%t))       //<yc> there was a stupid bug
      else boolean)       // boolean, or any U boolean ?

c_code(self:Exists,s:class) : any
 -> let %t := c_type(self.set_arg) in
     (range_infers_for(self.var, pmember(%t),%t),
      if (self.other = true)     		// forall
        c_code(Call(not,
                    list(For(var = self.var, set_arg = self.set_arg,
                             arg = If(test = Call(not,list(self.arg)),
                                      arg = Return(arg = true))))),
               s)
     else if (self.other = unknown)     // some
        let v := Variable!(self.var.pname /+ "_some",
                                   (OPT.max_vars :+ 1, 0),
                                   extends(self.var.range)) in  // v0.02
          c_code(Let(var = v, value = unknown,
                     arg = Do(list(For(var = self.var,
                                       set_arg = self.set_arg,
                                       arg =
                                       If(test = self.arg,
                                          arg =
                                            Return(arg = Assign(var = v, arg = self.var)))),
                                 v))),
                 s)
     else c_code(Call(boolean!,
                     list(For(var = self.var, set_arg = self.set_arg,
                              arg = If(test = self.arg, arg = Return(arg = true))))),
                 s))                     // exists

// am Image builds a set
c_type(self:Image) : type
 -> let %t := ptype(c_type(self.set_arg)) in             // v3.2.01
     (range_infers_for(self.var, pmember(%t),%t),
      if known?(of,self) Core/param!(set,self.of)
      else set[ c_type(self.arg) ])

c_type(self:Select) : type
 -> let %t := c_type(self.set_arg) in
     (range_infers_for(self.var, pmember(%t),%t),
      if known?(of,self) Core/param!(set,self.of)
      else set[ pmember(c_type(self.set_arg))] )

// new in v3.1.06 : proper type inference !
c_type(self:Lselect) : type
 ->  let %t := c_type(self.set_arg) in
       (range_infers_for(self.var, pmember(%t),%t),
        if known?(of,self) Core/param!(list,self.of)
        else list[ pmember(c_type(self.set_arg))] )

//______________________  while/until  __________________________________

// similar to a For
c_type(self:While) : type -> infers_from(return_type(self.arg),self)

c_code(self:While,s:class) : any
 -> (let b := OPT.protection in
       (write(protection, OPT, false),
        let r := While(test = c_boolean(self.test),
                       arg = c_code(self.arg, void),
                       other = self.other) in
          (if (OPT.protection & OPT.loop_index >= 0) OPT.loop_gc := true,
           write(protection, OPT, (OPT.protection | b)),
           if (s != void & s != any)
             (//[5] ... insert a to_C with s = ~S for ~S // s,self,
              to_C(arg = r, set_arg = s)) // v3.3
           else r)))


// *********************************************************************
// *     Part 6: Iterate                                               *
// *********************************************************************

// finds the right restriction of Iterate
// Iterate applies to the non-evaluated types (meta level)
[Iterate!(self:Iteration) : any
 -> restriction!(Iterate,
                 list(set(self.set_arg), set(self.var), any), true) ]

// iteration methods
// note the beauty of this: we only apply the code transformation if
// we actually get a constant Interval
[iterate(x:Interval,v:Variable[range:subtype[integer]],e:any) : any
 => let v := eval(x.arg1,Interval),
        %max:integer := eval(x.arg2,Interval) in     // 2.4.07  => must protect !
       while (v <= %max) (e, v :+ 1) ]

iterate(x:array,v:Variable,e:any) : any
 => (let %i := 1, %a := x,
         %max := length(%a) in
       while (%i <= %max) let v := %a[%i] in (e, %i :+ 1))

Iterate(x:class,v:Variable,e:any) : any
 => (for %v_1 in x.descendents
       let %v_2 := (for v in %v_1.instances e) in (if %v_2 break(%v_2)))

Iterate(x:..[tuple(integer, integer)],v:Variable,e:any) : any
 => (let v := eval(x.args[1]),
         %max := eval(x.args[2]) in
        while (v <= %max) (e, v :+ 1))

Iterate(x:Lselect,v:Variable,e:any) : any
 => (for v in eval(x.set_arg) (if eval(substitution(x.arg, x.var, v)) e))

Iterate(x:Select,v:Variable,e:any) : any
 => (for v in eval(x.set_arg) (if eval(substitution(x.arg, x.var, v)) e))

Iterate(x:Collect,v:Variable,e:any) : any
 => (for C%v in eval(x.set_arg)
       let v := eval(substitution(x.arg, x.var,C%v)) in e)

Iterate(x:but[tuple(any, any)],v:Variable,e:any) : any
 => (for v in eval(x.args[1]) (if (v != eval(x.args[2])) e))

Iterate(x:/+[tuple(any, any)],v:Variable,e:any) : any
 => (for v in eval(x.args[1]) e, for v in eval(x.args[2]) e)


//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| odefine.cl                                                  |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

// *********************************************************************
// *  Table of contents                                                *
// *     Part 1: Set, List and Tuple creation                          *
// *     Part 2: Object definition                                     *
// *     Part 3: Method instantiation                                  *
// *     Part 4: Inverse Management                                    *
// *********************************************************************

// *********************************************************************
// *     Part 1: Set, List and Tuple creation                          *
// *********************************************************************

// type inference has changed in v3.2:
c_type(self:List) : type
 -> (//[5] call c_type with ~S -> ~S // self, get(of,self),
     if known?(of,self) Core/param!(list,self.of)
     else let %res:any := {} in
            (for %x in self.args
               (if %res %res :meet class!(ptype(c_type(%x)))     // v3.3 : use ptype !
                else %res := class!(ptype(c_type(%x)))),
             nth(list,%res)))

// compile a List: take the of parameter into account !
[c_code(self:List) : any
 -> OPT.allocation := true,
    let x := List(args = list{ c_gc!(c_code(%x,any), c_type(%x)) |
                                        %x in self.args}) in
       (if known?(of,self)
          (if (compiler.safety > 4 | self.of = {} |
               forall(%x in self.args | c_type(%x) <= self.of))
              (x.of := self.of, x)
           else (warn(),
                 trace(2,"unsafe typed list: ~S not in ~S [262]\n",
                       list{c_type(%x) | %x in self.args}, self.of),
                 c_code( Call(Core/check_in,list(x,list,self.of)), list)))
        else x) ]

// new in v3.2: static list have type inference !         
c_type(self:Set) : type
 -> (//[5] call c_type with ~S -> ~S // self, get(of,self),
     if known?(of,self) Core/param!(set,self.of)
     else let %res:any := {} in
           (for %x in self.args
               (if %res %res :meet class!(c_type(%x))
                else %res := class!(c_type(%x))),
             nth(set,%res)))

[c_code(self:Set) : any
 ->  OPT.allocation := true,
     let x := Set(args = list{ c_gc!(c_code(%x,any), c_type(%x)) |
                               %x in self.args}) in
        (if known?(of,self)
          (if (compiler.safety > 4 | self.of = {} |
               forall(%x in self.args | c_type(%x) <= self.of))
              (x.of := self.of, x)     // the set expression is type safe
           else (warn(),
                 trace(2,"unsafe typed set: ~S not in ~S [262]\n",
                       list{c_type(%x) | %x in self.args}, self.of),
                 c_code( Call(Core/check_in,list(x,set,self.of)), set)))
         else x) ]

[c_type(self:Tuple) : type -> tuple!(list{c_type(x) | x in self.args}) ]

[c_code(self:Tuple) : any
 -> OPT.allocation := true,
    Tuple(args = list{ c_gc!(c_code(%x,any), c_type(%x)) |%x in self.args}) ]


// ******************************************************************
// *      Part 2: Compiling Definitions                             *
// ******************************************************************

c_type(self:Definition) : type ->
  (if (self.arg Core/<=t exception) {} else self.arg)

Compile/*name*:symbol := symbol!("_CL_obj")     // */

// creation of a new object
//
c_code(self:Definition,s:class) : any
 -> (let %c := self.arg,
         %v:Variable := Variable!(*name*, (OPT.max_vars :+ 1, 0), %c),
         %x := total?(%c, self.args) in
       (if (%c.open <= 0) error("[105] cannot instantiate ~S", %c),     // v3.2.44
        if %x c_code(%x, s)
        else c_code(Let(var = %v,
                        value = Cast(arg = c_gc!(c_code(Call(mClaire/new!, list(%c)), object)),
                                     set_arg = %c),
                        arg = Do(args = analyze!(%c, %v, self.args, list()))),
                    s)))

// tells if a "total instantiation" is appropriate (for exceptions)
// we actually check that the srange is OID or integer for all slots
[total?(self:class,l:list) : any
 ->  let lp := get_indexed(self),
         n := length(lp) in
       (if (not(compiler.diet?) & length(l) = n - 1 & 
            (self.open = ephemeral() | self Core/<=t exception) &
            n <= 4 & forall(i in (2 .. n) | srange(lp[i]) % {any,integer}))
         let %c:any := Call((if (length(l) = 0) mClaire/new! else anyObject!),
                        self cons list{ c_gc!(c_code(x.args[2],any)) | x in l}),  // v3.00.10
             m := (close @ self) in
           (if not(self <= exception) OPT.allocation := true,                    // v3.2.32 !
            if (length(l) = 0) %c := c_code(%c),
            if m Call_method1(arg = m, args = list(%c)) else %c)
        else false) ]


// the instantiation body is a sequence of words from which the initialization
// of the object must be built. This method produces a list of CLAIRE instructions
// self is the object (if named) or a variable if unamed
// [in ClReflect.cpp] we create an object from prototype = list of OK defaults
// OK defaults = object (for object) + float (for float) + integer (for anything)
//               + NULL for objects
[analyze!(c:class,self:any,%l:list,lp:list) : any
 -> let ins?:boolean := (c.open != 4 & not(lp) & not(compiler.class2file?)), // PATCH!
        r := list<any>{ (let p := x.args[1], y := x.args[2],
                             s := (p @ c), special? := (p.open = 0 & s % slot) in
                       (lp :add p,
                        Call((if special? put else write),
                                  list(p, self,
                                    (if (not(special?) | c_type(y) <= s.range) y
                                     else c_check(c_code(y, any),
                                                  c_code(s.range, type))))))) |
                      x:Call in %l} in
       (if ins? r :add Call(selector = add, args = list(instances, c, self)),
        if not(compiler.class2file?)      // otherwise the constructor takes care of it
          for s:slot in get_indexed(c)
          let p := s.selector,
              v := get(default, s) in
            (if (known?(v) & (if multi?(p) v else true) & not(p % lp) &
                 (known?(inverse, p) | known?(Kernel/if_write, p) |
                  (srange(s) != object & srange(s) != float & not(v % integer))))
               let defExp := (if designated?(v) v // v3.0.43, was: c_code(v,any) // ?? NEW
                              else Call(default, list(Cast(arg = Call(@,list(p, c)),
                                                           set_arg = slot)))) in
                r :add
                  // REMOVED AS WELL (if (srange(s) = float) Call(mClaire/update,list(p,self,s.index,float,defExp))
                    Call(write,list(p,self,defExp))),
        let m := (close @ c) in
          r :add (if m Call_method1(arg = m, args = list(self)) else self),
        r) ]

// creation of a new named object
c_code(self:Defobj,s:class) : any
 -> let %a := OPT.allocation,
        %c := self.arg, o := get(self.Language/ident),
        %v := (if (known?(o) & not(o % global_variable)) o
               else Variable!(*name*, (OPT.max_vars :+ 1, 0), %c)),
        %y1 := Call(object!, list(self.Language/ident, %c)),
        %y2 := analyze!(%c, %v, self.args, list(name)),
        %x:any := (if not(%v % Variable) Do(%y1 cons %y2)
                   else  Let(var = %v, value = %y1, arg = Do(%y2))) in
       (//[5] compile defobj(~S) -> ~S // self, o,
        if (%c.open <= 0) error("[105] cannot instantiate ~S", %c),          // v3.2.44
        if known?(o)
           (if not(o % OPT.objects)
               (OPT.objects :add o, c_register(o)))
        else (warn(),trace(2, "~S is unknown [265]\n", self.Language/ident)),
        %x := c_code(%x, s),
        if (self.arg <= exception) OPT.allocation := %a,          // v3.2.24 : no GC for exceptions
        %x)

// creation of a new named object
[c_code(self:Defclass,s:class) : any
 -> let  %name := self.Language/ident, o := get(%name),
         %create := (if known?(o) Call(class!, list(%name, self.arg))
                     else error("[internal] cannot compile unknown class ~S",%name)),
         %x := Do( %create cons
                  (list{ (let v := unknown in       // default value
                          (case x (Call (v := x.args[2], x := x.args[1])),
                           Call(add_slot,
                                list(o, Language/make_a_property(x.Core/pname),
                                     x.range, v, 0)))) |     // v3.2 add index 0
                              x in self.args} /+
                  (if self.params
                      list(Call(put, list(params, o, self.params)))
                   else list()))) in
       (if not(o % OPT.objects)
         (OPT.objects :add o, c_register(o)),
        c_code(%x, s)) ]


claire/SHIT:any :: 1

// method definition
// note (3.4): using the un-compiled code for c_status is weak, it would be much better to
// extend c_status to optimized code (modulo the double-bug issue)
//
c_type(self:Defmethod) : type -> any
[c_code(self:Defmethod) : any
 -> let px := self.arg.selector,
        l := self.arg.args,
        lv := (if (length(l) = 1 & l[1] = system) list(Variable!(*name*, 0, void))
               else l),
        ls := extract_signature!(lv),
        lrange := Language/extract_range(self.set_arg, lv, LDEF),
        sdef:any := (if (self.inline? & compiler.inline?)
             (print_in_string(),
              printf("lambda[(~I),~S]", Language/ppvariable(lv), self.body),
              end_of_string())),
        lbody := extract_status_new(self.body),    // reuse the method from define.cl
        getm := (px @ ls[2]),
        m:method := (case getm (method getm,
                     any error("[internal] the method ~S @ ~S is not known",px,ls[2]))),
        olds := get(status, m) in
     (lbody[2] := get(functional,m),
      if (not(compiler.inline?) & (px = Iterate  | px = iterate)) nil
      else if (lrange[1] = void & sort_pattern?(lv,self.body)) sort_code(self,lv)                         // v3.3
      else (if (lbody[3] != body)
             let na := function_name(px, ls[2], lbody[2]),
                 la := Language/lambda!(lv, lbody[3]),
                 news := (if OPT.recompute c_status(la.body,la.vars)
                          else status!(m)) in
             (compile_lambda(na, la, m),
              if (unknown?(lbody[1]) | OPT.recompute)
                 (if (not(OPT.use_nth=) & news[BAG_UPDATE]) news :- ^2(BAG_UPDATE),
                  if (not(OPT.use_update) & news[SLOT_UPDATE]) news :- ^2(SLOT_UPDATE),
                  if (not(OPT.use_string_update) & news[STRING_UPDATE]) news :- ^2(STRING_UPDATE), // v3.3.48
                  if (not(OPT.allocation) & news[NEW_ALLOC]) news :- ^2(NEW_ALLOC),
                     trace(4,"---- CHANGE: status(~S)= ~S to ~S\n",m,olds,news),
                  lbody[1] := news),
              lbody[2] := make_function(na)),
            if (self.set_arg % global_variable) lrange[1] := self.set_arg
            else if (m.range % class & not(lrange[1] % class)) lrange[1] := m.range,
            let %m := add_method!(m, ls[1], lrange[1], lbody[1], lbody[2]) in
                c_code((if (self.inline? & compiler.inline? & not(compiler.diet?))
                           Call(inlineok?, list(%m, sdef))
                        else if (lrange[2] & not(compiler.diet?))
                           let na := (function_name(px, ls[2], lbody[2]) /+
                                        "_type") in
                             (compile_lambda(na, lrange[2], type),
                              Call(write, list(typing, %m, make_function(na))))
                        else %m)))) ]


// v3.3 : we optimize a single sort definition -----------------------------------------------
// [foo(x:list) : list -> sort(m,x) ]
[sort_pattern?(lv:list,%body:any) : boolean
  -> ( (length(lv) = 1) &
       (case %body (Call (%body.selector = sort &
                          (let a1 := %body.args[1] in
                             (case a1 (Call (a1.selector = @ & a1.args[1] % property)))) &
                          lexical_build(%body.args[2],lv,0) = lv[1]),
                    any false))) ]



// this is the macroexpansion of the quick_sort which is difficult because of the dual recursion
// Thus, we generate two methods for one definition, and produce the explicit code for the specialized
// quicksort (v3.3)
[sort_code(self:Defmethod, lv:list) : any
  -> let l := lv[1], f := self.body.args[1].args[1],           // sort_pattern(self) = true !
         m := Variable!(symbol!("m"), 0, integer),
         n := Variable!(symbol!("n"), 0, integer),
         x := Variable!(symbol!("x"), 0, member(l.range)),
         p := Variable!(symbol!("p"), 0, integer),
         q := Variable!(symbol!("q"), 0, integer),
         def1 := Defmethod(arg = self.arg,  inline? = false,  set_arg = self.set_arg,
                           body = Call(self.arg.selector,
                                       list(1, Call(length, list(lv[1])), l))),
         %bd := If(test = Call(>, list(m,n)),
                   arg = Let(var = x, value = Call(nth,list(l,n)),
                             arg = If(
                       test = Call(=,list(m,Call(+,list(n,1)))),
                       arg = If(test = Call(f,list(Call(nth,list(l,m)), x)),
                                arg = Do(list(Call(nth=,list(l,n,Call(nth,list(l,m)))),
                                              Call(nth=,list(l,m,x))))),
                       other = Let(var = p, value = Call(>>,list(Call(+,list(n,m)), 1)),
                                   arg = Let(var = q, value = n,
                                             arg = Do(list(
                          Assign(var = x, arg = Call(nth,list(l,p))),
                          If(test = Call(!=,list(p,n)),
                             arg = Call(nth=,list(l,p,Call(nth,list(l,n))))),
                          For(var = p, set_arg = Call(..,list(Call(+,list(n,1)),m)),
                              arg = If(test = Call(f,list(Call(nth,list(l,p)),x)),
                                       arg = Do(list(Call(nth=,list(l,n,Call(nth,list(l,p)))),
                                                     Assign(var = n, arg = Call(+,list(n,1))),
                                                     If(test = Call(>,list(p,n)),
                                                        arg = Call(nth=,list(l,p,Call(nth,list(l,n))))))))),
                          Call(nth=,list(l,n,x)),
                          Call(self.arg.selector, list(q,Call(-,list(n,1)),l)),
                          Call(self.arg.selector, list(Call(+,list(n,1)),m,l))))))))),
         def2 := Defmethod(arg = Call(self.arg.selector, list(n,m,l)),
                           inline? = false,  set_arg = self.set_arg,
                           body = %bd) in
       (//[2] ---- note: quick sort optimisation for ~S ---- // self.arg.selector,
        eval(def2),                    // we need the method in the system
        Do(list(c_code(def1),
                c_code(def2)))) ]

// new: we deal with floats --------------------------------------

// create a restriction so that OPT is happy
add_method(p:property,ls:list,rg:type,st:integer,f1:function,f2:function) : method
  -> add_method(p,ls,rg,st,f1)

[add_method!(m:method,ls:list,rg:any,stat:any,fu:function) : any
  -> let %c :=  Call_method(arg = (add_method @ property),
                            args =  list(c_code(m.selector,property),
                                         c_code(ls,list),
                                         c_code(rg,type), stat, fu)) in
       (if (m.range = float | float % m.domain | m.range % tuple)
           %c.args :add make_function(string!(fu) /+ "_"),
        %c) ]

extract_status_new(x:any) : list
 -> (let s := unknown,
         f := (if (case x (Call x.selector = function!)) x else unknown) in
       (case x
         (And let y := x.args[1] in
                (if (case y (Call y.selector = function!))
                    (f := y, x := x.args[2])),
          Call (if (x.selector = function!) x := body)),
        if known?(f)
           (x := body,
            if (length(f.args) > 1)(try s := integer!({eval(u) | u in cdr(f.args)}
                                                      as set<integer>)
                                    catch any (warn(),
                                               SHIT := cdr(f.args),
                                               trace(2,"wrong status ~S -> ~S [266]\n",
                                                        f,set!(cdr(f.args))),
                                               s := 0))
            else s := 0,
            f := make_function(string!(extract_symbol(f.args[1])))),
        list(s, f, x)))

// this signature extraction is more subtle since it also builds an external
// list. (l1 is the domain (may use global variables), l2 is the "pure"
// list of patterns)
[extract_signature!(l:list) : list
 -> LDEF := list<any>(),
    let n := 0,
        l1 := list<type>(),    // v3.2.18
        l2 := list<any>{ (let p := Language/extract_pattern(v.range, list(n)) in
                        (n :+ 1,
                         l1 :add! (if (v.range % global_variable) v.range else p),
                         put(range, v, Language/type!(p)),
                         p)) |
                     v:Variable in l} in
      list(l1, l2) ]

// check signature equality
=sig? :: operation()
=sig?(x:list,y:list) : boolean -> (tmatch?(x, y) & tmatch?(y, x))

// creates a name for a restriction from the full domain
// Note that we suppose that a new restriction is not allowed to be inserted
// in a list of restrictions when the property is closed.
//
function_name :: property(open = 3)
[function_name(p:property,l:list,x:any) : string
 -> if (x % function) string!(x as function)
    else let n := 0,
              m := 0,
              md := module!(name(p)),
              c := class!(l[1]),
              r:string := ((string!(p.name) /+ "_") /+ string!(c.name)) in
            (if (compiler.naming = 0 & p != main)     // v3.1.04
               r := (string!(md.name) /+ "_") /+ r,
             for r in p.restrictions
               (if (c = domain!(r)) n :+ 1, if (l =sig? r.domain) m := n),
             r := (if (n <= 1) r else r /+ string!(m)),
             if (stable?(p) | p = main) r                         // important main is NOT qualified !
             else (r /+ "_") /+ string!(module!().name)) ]

// this compiles a lambda into a C method with name oself.
// the use_new flag will be raised if a new object is created inside the
// function.
// m is either the associated method,or the expected range
//
compile_lambda(self:string,l:lambda,m:any) : any
 -> let x := compiler.safety,y := l in
       (trace(3, "---- Compiling ~A,\n", self),
        case m (method OPT.in_method := m),
        OPT.protection := false,
        OPT.allocation := false,
        if (OPT.loop_index > 0) OPT.loop_index := 0,
        OPT.loop_gc := false,
        OPT.use_update := false,
        OPT.use_nth= := false,
        OPT.use_string_update := false,                    // v3.3.46
        OPT.max_vars := 0,
        if (m % OPT.unsure) compiler.safety :=  1,
        make_c_function(l, self, m),
        OPT.in_method := unknown,
        compiler.safety := x,
        true)

// how to compile an table definition
//
[c_code(self:Defarray) : any
 -> let a := (self.arg as Call).args,
        %a := get(extract_symbol(a[1])),
        %v := (case %a (table %a, any error("[internal] the table ~S is unknown", a[1]))),
        s := %a.domain,
        e := (let l := cdr(a),
                  b := Language/lexical_build(self.body, l, 0) in
                (if exists(va in l | Language/occurrence(b, va) > 0) lambda!(l, b)
                 else self.body)),
        d := (case e (lambda unknown, any self.body)),
        %l1 := (if %a.multivalued?
                   list<any>(Call(put, list(multivalued?, %v, %a.multivalued?)))
                else list<any>()),
        %l2 := list<any>(Call(put, list(range, %v, %a.range)),
                         Call(put, list(params, %v, %a.params)),
                         Call(put, list(domain, %v, s))) in
       (put(range, (a[2] as Variable),
            Language/extract_type((a[2] as Variable).range)),
        if (length(a) = 2)
           (%l2 :add
              Call(put,
                   list(Kernel/graph, %v,
                          (case s
                            (Interval Call(make_copy_list, list(size(s), d)),
                             any Call(make_list, list(29, unknown)))))),
            %l2 :add
              (case e
                (lambda For(var = a[2], set_arg = s,
                            arg = Call(nth=, list(%v, a[2], e.body))),
                 any Call(selector = put, args = list(default, %v, d)))))
        else let s2 := extract_type((a[3] as Variable).range) in
               (put(range, (a[3] as Variable), s2),
                %l2 :add
                  Call(put,
                       list(Kernel/graph, %v,
                              Call(make_copy_list,
                                   list(length(%a.Kernel/graph),
                                          (if (%a.params = any) unknown
                                           else %a.default))))),
                %l2 :add
                  (case e
                    (lambda
                       For(var = a[2], set_arg = s[1],
                           arg =
                             For(var = a[3], set_arg = s2,
                                 arg = Call(nth=, list(%v, a[2], a[3], e.body)))),
                     any Call(put, list(default, %v, d))))),
        OPT.objects :add %a,
        c_register(%a),
        c_code(Do( Call( object!, list(%a.name, table)) cons (%l1 add* %l2)),
               any)) ]


// *********************************************************************
// *     Part 4: Inverse Management (new in v3.0.50)                   *
// *********************************************************************


// this method creates an if_write demon that takes care of the inverse
Compile/compute_if_write_inverse(R:relation) : void
 -> let x := Variable(pname = symbol!("XX"), range = R.domain),
         y := Variable(pname = symbol!("YY"), range = (if multi?(R) member(R.range) else R.range)),
         z := Variable(pname = symbol!("ZZ"), range = R.range),
         l1 := list<any>() in
     (if multi?(R)
         (// generate an if_write demon that does the add!
          l1 := list<any>(Produce_put(R,x,y)),
          if known?(inverse,R)
            l1 :add Produce_put(R.inverse,y,x),
          R.if_write := lambda!(list(x,y),
                                If(test = Call(not, list(Call(%, list(y,Produce_get(R,x))))),
                                   arg = Do(l1))))
      else (//generate an if_write demon that does the put
            l1 := list<any>(Produce_put(R,x,y)),
            if known?(inverse,R)
               (l1 :add If(test = Call(known?, list(z)),
                           arg = Produce_remove(R.inverse,z,x)),
                l1 :add Produce_put(R.inverse,y,x)),
            R.if_write := lambda!(list(x,y),
                                  Let(var = z,
                                      value = Produce_get(R,x),
                                      arg = If(test = Call(!=,list(y,z)),
                                      arg = Do(l1))))),
      let dn := string!(R.name) /+ "_write" in
          (Compile/compile_lambda(dn, R.if_write, void)))

// generate a demon to perform x.R := s (s is a set)
Compile/compute_set_write(R:relation) : any
 -> let x := Variable(pname = symbol!("XX"), range = R.domain),
        y := Variable(pname = symbol!("YY"), range = bag),
        z := Variable(pname = symbol!("ZZ"), range = member(R.range)),
       l1 := list<any>() in
     (//[0] compute set_write for ~S // R,
      if known?(inverse,R)
         l1 :add For(var = z, set_arg = Produce_get(R,x),
                     arg = Produce_remove(R.inverse,z,x)),
      l1 :add Produce_erase(R,x),
      l1 :add For(var = z, set_arg = y,
                  arg = Produce_put(R,x,z)),
      let dn := string!(R.name) /+ "_set_write" in
          Compile/compile_lambda(dn, lambda!(list(x,y),Do(l1)), void))

// generate a simple put for a property => generate a case to make sure
// that we get the fastest possible code
Compile/Produce_put(r:property,x:Variable,y:any) : any
  -> let l := list<any>() in
       (for xs in {xs in r.restrictions | (xs % slot & ptype(x.range) ^ domain!(xs)) }
          l :add* list(domain!(xs),
                       (if r.multivalued? Call(add!,
                                           list(Call(r, list(Cast(arg = x, set_arg = domain!(xs)))), y))
                        else Call(put, list(r,Cast(arg = x, set_arg = domain!(xs)), y)))),
        if (length(l) = 2) l[2]
        else Case(var = x, args = l))

// generate a simple erase (the inverse management has been done)
// v3.2.50: use ptype(x.range) for variable whose type is t U any :-)
Compile/Produce_erase(r:property,x:Variable) : any
  -> let l := list<any>(),
         val := (if (r.multivalued? = list) list<any>() else set<any>()) in
       (cast!(val,member(r.range)),
        for xs in {xs in r.restrictions | (xs % slot & ptype(x.range) ^ domain!(xs)) }
          l :add* list(domain!(xs),
                       Call(put, list(r,Cast(arg = x, set_arg = domain!(xs)),
                                        (if r.multivalued? val else xs.default)))),  // v3.2.50
        if (length(l) = 2) l[2]
        else Case(var = x, args = l))

// note:  (a) Simpler because of v3.0 !! (siude-effects on lists or sets)
//        (b) if |l|= 1 domain!(r) = domain!(x) because of tighten

// same for a table
Compile/Produce_put(r:table,x:Variable,y:any) : any
 -> Call(put, list(r,x,
                   (if r.multivalued? Call(add,list(list(nth,list(r,x)), y))
                    else y)))

  
Compile/Produce_get(r:relation,x:Variable) : any
 -> (case r (table  Call(nth, list(r,x)),
             property   let l := list<any>() in
                          (for xs in {xs in r.restrictions |
                                      (xs % slot & ptype(x.range) ^ domain!(xs)) }
                             l :add* list(domain!(xs),
                                          Call(r, list(Cast(arg = x, set_arg = domain!(xs))))),
                           if (length(l) = 2) l[2]
                           else Case(var = x, args = l))))
 
// generate a remove
Compile/Produce_remove(r:property,x:Variable,y:any) : any
  -> let l := list<any>() in
       (for xs in {x in r.restrictions | x % slot}
        l :add* list(domain!(xs),
                     (if r.multivalued? Call(delete,list(Call(r,list(x)),y))
                      else Call(put, list(r,x,unknown)))),
        if (length(l) = 2) l[2]
        else Case(var = x, args = l))

// same for a table
Produce_remove(r:table,x:Variable,y:any)  : any
 -> Call(put, list(r,x,
                   (if r.multivalued? Call(delete,list(list(nth,list(r,x)), y))
                    else unknown)))


Compile/Tighten(r:relation) : void
  -> (case r (property
                 let ad:type := set(), ar:type := set() in
                   (for s in {x in r.restrictions | x % slot}
                      (ad :U domain!(s),
                       ar :U (if multi?(r) member(s.range) else s.range)),
                    r.open := 1,
                    put(domain,r,class!(ad)),
                    put(range,r,
                         (if (r.multivalued? = list) Core/param!(list,class!(ar))
                          else if (r.multivalued? = set) Core/param!(set,class!(ar))
                          else ar)),
                    trace(5,"~S -> ~S x ~S\n", r, r.domain,r.range))))


// new: re-compute the numbering but without the side-effects of the interpreter version (v3.067)
Compile/lexical_num(self:any,n:integer) : void
 -> (case self
      (Call lexical_num(self.args, n),
       Instruction let %type:class := self.isa in
          (if (%type % Instruction_with_var.descendents)
                (put(index, self.var, n),
                 n := n + 1,
                 if (n > *variable_index*) *variable_index* := n),
           for s in %type.slots lexical_num(get(s,self), n)),
      bag (for x in self lexical_num(x, n)),
      any nil))


// v3.2 -----------------------------------------------------------------

c_type(self:Defrule) : type -> any
              
// compile a rule definition
c_code(self:Defrule,s:class) : any
 -> let ru := get(self.iClaire/ident), l := list<any>() in
       (//[0] compile a rule ~S // ru,
        for r in Language/relations[ru] 
            (if not(Language/eventMethod?(r)) Tighten(r)),   // ensures better code generation  
        for r in Language/relations[ru]
          (if (open(r) < 2) l :add Call(final, list(r)),
           compile_if_write(r),
           let dn := (r.name /+ "_write"),
               s := string!(dn),
               lb := r.if_write in
             (compile_lambda(s, lb, void), 
              l add Call(put,list(if_write,r,make_function(s))))),
        for r in Language/relations[ru]
          (if Language/eventMethod?(r)
              l :add compileEventMethod(r as property)),
        c_code(Do(l), s))
      
// produce a beautiful if_write demon
compile_if_write(R:relation) : void
 -> let l := demons[R],
        lvar := l[1].formula.vars,  // list(x,y) from 1st demon
        l1 := list<any>(Produce_put(R,lvar[1],lvar[2])),
        l2 := list<any>{ substitution(
                         substitution(
                         substitution( x.formula.body,x.formula.vars[3],lvar[3]),
                         x.formula.vars[1], lvar[1]),
                         x.formula.vars[2], lvar[2]) |  x in l} in
     (put(range,lvar[1],domain(R)),
      put(range,lvar[2],range(R)), 
      for v in lvar put(range,v,class!(v.range)),
      if (l2[1] % If & not(Language/eventMethod?(R)))
         (if ((l2[1] as If).test % And)
             ((l2[1] as If).test := And(args = cdr((l2[1] as If).test.args)))
          else l2[1] := (l2[1] as If).arg),        // first test is useless :)
      if known?(inverse,R)
         (if not(multi?(R)) l1 :add Produce_remove(R.inverse,lvar[3],lvar[1]),
          l1 :add Produce_put(R.inverse,lvar[2],lvar[1])),
       R.if_write := lambda!( list(lvar[1],lvar[2]),
         (if Language/eventMethod?(R) Do(l2)
          else if multi?(R)
             If(test = Call(not,
                            list(Call(%,list(lvar[2],Language/readCall(R,lvar[1]))))),
                arg = Do(l1 /+ l2))
          else Let(var = lvar[3],
                   value = Language/readCall(R,lvar[1]),
                   arg = If(test = Call(!=,list(lvar[2],lvar[3])),
                            arg = Do(l1 /+ l2))))))
               
// create a simple method that will trigger the event
compileEventMethod(p:property) : any
 -> let m:method := p.restrictions[1],
        na := string!(p.name) /+ "_write" in
      add_method!(m,list(p.domain,p.range),void,0,make_function(na))    
 

//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| osystem.cl                                                  |
//| Copyright (C) 1994 - 2003 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

//-------------------------------------------------------------------
// This file contains the gloabal parameter objects and the key methods
// This are the key methods
//
//  c_type(x)  is the CLAIRE type of x
//  c_code(x)  is an optimized instruction
//  & c_code(x,s) is an optimized expression of sort s
//  c_gc?(x)   [boolean] true if x must be protected from garbage collection
//  c_sort(x)  the sort of the expression x (precise sort)
//  c_status(x,l) [bitvector] abstract interpretation of x according to a set
//             of criterions (allocation, update, etc...)
//
// the sorts are integer, char, x <= imported, object, entity
//-----------------------------------------------------------------


// ******************************************************************
// *   Table of contents                                            *
// *    Part 1: General Global Variables and Properties             *
// *    Part 2: The defaults for c_type, c_code, c_gc and c_sort    *
// *    Part 3: c_new, c_sort, c_fonc                               *
// *    Part 4: Names & identifiers management                      *
// *    Part 5: On-line optimization                                *
// ******************************************************************

// import
// Compile/index :: Kernel/index
Compile/srange :: Kernel/srange
Compile/typing :: Kernel/typing
Compile/status :: Kernel/status
Compile/tmatch? :: Core/tmatch?
// Compile/test :: Language/test
//Compile/set_arg :: Language/set_arg
Compile/pname :: Core/pname
//Compile/other :: Language/other
Compile/if_write :: Kernel/if_write
// Optimize/extract_symbol :: Language/extract_symbol

// where to find the CLAIRE libraries
claire/home() : string -> getenv("CLAIRE3_HOME")     // TO CHANGE -> simply read claire_home


// ******************************************************************
// *    Part 1: General Global Variables and Properties             *
// ******************************************************************

// we use an optimizer object with all the necessary resources
// they are all private.
meta_OPT <: thing(
	Compile/instructions:list,        // list of compiled instructions
        Compile/objects:list,          // new named objects that are defined - v3.3.3: the order is important
        Compile/properties:set<property>, // new properties (implicit)
        Compile/functions:list,           // new functions
        Compile/need_to_close:set,        // properties that need to be closed
        Compile/need_modules:set,         // other modules that are needed
        Compile/legal_modules:set,        // modules that are allowed
        Compile/allocation:boolean = false,    // status: use an allocation
        Compile/protection:boolean = false,    //         use a GC protection
        Compile/alloc_stack:boolean = false,   //         use a stack allocation
        Compile/ignore:set,               // do not print
        Compile/to_remove:set,            // do not compile
        Compile/cinterface:port,          // port for the .h output
        Compile/outfile:port,             // port for the .Cpp output
        Compile/max_vars:integer = 0,          // max number of local variables
        Compile/loop_gc:boolean = false,       // used to signal that we optimize a loop
        Compile/loop_index:integer = 0,        // max index of var in loop
        Compile/level:integer = 0,            // indentation level
        Compile/in_method:any = unknown,      // current method (used to print context info)
        Compile/profile?:boolean = false,     // do we use the profiler
        Compile/cfile:any = false,            // used for file compilation mode
        use_update:boolean = false,    // used to record update for status
        use_nth=:boolean = false,      // update on bags
        online?:boolean = false,       // online optimization
        recompute:boolean = true,      // recompute the status
        unsure:list = nil,             // methods that need to be compiled at safety 1
        knowns:set<relation>,          // properties that are safe (no unknown)
        Compile/simple_operations:set<property>,   //  v3.3
        Compile/non_identifiable_set:set<class>,   // v 3.3
        Compile/use_string_update:boolean = false)     // update on strings   v3.3.46
       

// The meta_compiler contains the definition of the compiler flags and slots
// that are important for the user. Other stuff is hidden in OPT
meta_compiler <: thing(external:string,             // name of the output
                       claire/headers:list<string>, // headers
                       source:string,               // where to put the produced code
                       claire/debug?:list<module>,  // generate instrumented code for modules
                       version:any,
                       claire/active?:boolean = false,     // active = (loading | compiling)
                       claire/safety:integer = 1,   // cf .. later
                       claire/env:string = "ntw",   // OS info
                       claire/naming:integer = 0,          // naming mode (0: normal, 1: self-compile, 2: protected)
                       claire/libraries:list<string>,      // libs to be included
                       claire/inline?:boolean = false,     // do we want to use inlining
                       claire/loading?:boolean = false,    // mode (read the file vs compile)
                       claire/class2file?:boolean = false, //
                       claire/greedy?:boolean = false,     // allow un-necessary allocation -> faster
                       claire/libraries_dir:list,          // regular/debug
                       claire/headers_dir:string,          // include directory
                       claire/options:list,                // list of options
                       claire/overflow?:boolean = false,   // safe arithmetic
                       claire/diet?:boolean = false,       // flag non-diet fragments
                       claire/optimize?:boolean = false)   // v3.2.56: record -O option

// v3.2.38: greedy is no longer used ! -> a plan was to generate a faster STORENTH but it has
// been discontinued. greedy? becomes a deprecated feature

// the three variables that are used in the main files
claire/claire_options:string :: "/w0 /zq"
claire/claire_lib:string :: ""
claire/claire_modules:list :: list{get_value(x) |
                                   x in list("Kernel","Core","Language","Reader")}

// safety:
//       0  -> super-safe (check returns & gc safe)
//       1  -> safe
//       2  -> we trust explicit types & super
//       3  -> no overflow checking (integer & arrays)
//       4  -> no selector errors, no range error
//       5  -> cross-compiling (i.e. no errors)
//       6  -> unsafe (no GC)
claire/compiler :: meta_compiler(
   external = Id(compiler.external),
   env = Id(compiler.env),
   version = Id(version()),
   source = "",
   headers_dir = "",
   libraries = list<string>("Kernel"),
   options = Id(compiler.options))

// re-definable items for bootstrap modifications
claire/c_type :: property(Core/open = 3, range = type)
claire/c_code :: property(Core/open = 3)
claire/c_gc :: property(Core/open = 3)
Compile/get_index :: property(range = integer, Core/open = 3)
Compile/get_indexed :: property(range = bag, Core/open = 3)
Compile/make_c_function :: property(Core/open = 3)
Compile/make_float_function :: property(Core/open = 3)
Compile/c_expression :: property(Core/open = 3)
Compile/bool_exp :: property(Core/open = 3)
Compile/c_statement :: property()
claire/c_interface :: property(Core/open = 3)
Compile/c_sort :: property(Core/open = 3)

// other useful properties
Compile/designated? :: property()
Compile/sort= :: property()
Compile/psort :: property()
Compile/osort :: property()                        // Optimizer version of sorts
Compile/compile_lambda :: property()
Compile/c_check :: property()
Compile/need_protect :: property()
member_code :: property()
Compile/c_strict_code :: property()                // code with strict (stupid) type
Compile/c_strict_check :: property(Core/open = 3)  // new: allow future overload !!
Compile/stupid_t :: property()
Compile/object! :: property()                      // compiler instantiation
Compile/anyObject! :: property(range = object)     // fast instantiation if all any slots are known
Compile/Cerror :: property()
Compile/self_code :: property()                    // how to compile a type expression
Compile/get_module :: property()
claire/main :: property()

// these are the classes defined especially for this module
Compile/to_protect <: Optimized_instruction(arg:any)
Compile/to_CL <: Optimized_instruction(arg:any,set_arg:class)
Compile/to_C <: Optimized_instruction(arg:any,set_arg:class)
Compile/C_cast <: to_C()
Pattern <: Type(selector:property,       //
                arg:list)                // the tuple is made into a list

// OPT contains all the parameters for the optimizer
claire/OPT :: meta_OPT(
    outfile = stdin, cinterface = stdin,
    ignore = set(mClaire/index!, mClaire/set_index, object!, mClaire/base!, mClaire/set_base,
                 mClaire/push!, anyObject!, mClaire/get_stack, mClaire/put_stack),
    to_remove = set(interface),
    knowns = set<relation>(arg1,arg2),                     // v3.1.12
    unsure = list(+ @ integer, * @ integer, - @ integer),
    simple_operations = {+, -, /, *},                      // v3.3
    non_identifiable_set =
                    Id(set<class>{c in class | exists(c2 in c.descendents | c2.ident? = false)}))



claire/safe(x:any) : type[x] -> x

// ******************************************************************
// *    Part 2: The defaults for c_type, c_code, c_gc and c_sort    *
// ******************************************************************


// basic type inference
[c_type(self:any) : type
 -> case self
      (Variable let r := get(range, self) in
                  (if (r = unknown) any
                   else if (case r (Union r.Core/t1 = {})) r.Core/t2.Core/t2
                   else ptype(r)),
       global_variable let r := self.range in
                         (if r r else set(self.value)),
       unbound_symbol Cerror("[215] the symbol ~A is unbound_symbol", self.name),
       error {},
       Update c_type(self.value),
       Construct (if not(self % (List U Set)) any
                 else let %res:type := {} in
                        (for %x in self.args
                           (if %res %res :meet class!(c_type(%x))
                            else %res := class!(c_type(%x))),
                         nth((case self (Set set, any list)),
                             %res))),
       Instruction error("c_type of ~S is not defined",owner(self)), //<yc:v0.01>
       any set(self)) ]

// compile into a sort and checks strict type matching (naive/stupid)
[c_strict_code(x:any,s:class) : any
 -> c_strict_check(c_code(x, s), s) ]

[c_strict_check(x:any,s:class) : any
 -> if (not(OPT.online?) & s inherit? object & not(stupid_t(x) inherit? s))
       (if (c_type(x) = any)     // v3.2.06 - avoid C++ compiler error !
           Cerror("Need explict cast: ~S is not a ~S",x,s),
        C_cast(arg = x, set_arg = s))
     else x ]

// using conversions. s is a sort or void (we do not need the value).
// note: we need s to be the precise sort for C++
// the is the default version that uses c_code(x)/ c_sort(x)
[c_code(x:any,s:class) : any
 -> let y := (case x (Call c_code_call(x,s), any c_code(x))),   // v2.4.9 safe sort for inline !
        z := c_sort(y) in
      (if (s = void | z = s | OPT.online?)
           (if (s = void & (case x (Call x.selector = =)))
               (warn(),
                trace(2,"-- Equality meant as an assignment: ~S [264]\n",x)),    // v3.3
            y)       // v3.0.44 BIG CHANGE
       else if (s = any)
         (if (z = integer & y % Call_slot &                       // need a proper slot
              not(compiler.overflow? & compiler.class2file?)) y   // UGLY: v3.0.42
          else if (y % to_C) arg(y as to_C)
          else (if (z = float)
                   (OPT.protection := true,             // v3.2.30 - implicit protection !
                    OPT.allocation := true),            // v3.2.30 - _float_ will cause an allocation
                to_CL(arg = y, set_arg = psort(c_type(y)))))
       else if (z = any) to_C(arg = y, set_arg = s)
       else y) ]

// basic code generation
// c_code without a sort parameter means that we do not care about the resulting sort,
// which will be checked later on using c_sort
[c_code(self:any) : any
 -> case self
      (unbound_symbol Cerror("[215] the symbol ~A is unbound_symbol", self.name),
       Variable self,
       global_variable (c_register(self), self),
       Optimized_instruction self,
       Instruction Cerror("[internal] c_code(~S) should have a parameter", self),
       set (if self
              let x :=  Set(args = list!(self)) in
                 (if (of(self) != void) x.of := of(self),
                  c_code(x))
            else self),
       list (if self
               let x := List(args = self) in
                    (if (of(self) != void) x.of := of(self),
                  c_code(x))
             else self),
       tuple c_code(Tuple(args = self)),
       any (if (self % thing) c_register(self),
            if (self % (float U function)) OPT.allocation := true,
            self)) ]

// basic gc protection
// v3.3.3 : do not protect float, which requires that they are stored properly
[Compile/c_gc?(self:any) : boolean
 -> case self
      (Variable false,
       global_variable not(gcsafe?(self.range)),
       Construct (OPT.loop_gc & (self % List | self % Set)), // v3.3.3  List constructors are SAFE_RESULT by construction
                                                             // but this protection is not enough in a loop
       Instruction false,            // defined recursively
       string OPT.use_string_update, // implies copy, which implies a protection (v3.3.48)
       any false) ]                  // TODO : protect functions !!!!

// gives the sort of a compiled expression (does not apply to instructions that
// have a direct c_code(x,s)
// v2.4.9: special type => special sorts !!!
[c_sort(self:any) : class
 -> case self
      (global_variable (if nativeVar?(self) (if (self.range = {}) osort(owner(self.value))
                                             else osort(self.range))
                        else any),    // v3.3 ! was any,
       Instruction case self
                   (Variable sort(self),
                    Assign sort(self.var),
                    Call osort(selector_psort(self)),
                    Call_method (if (self.arg.selector = externC & length(self.args) = 2)
                                    psort(self.args[2] as class)
                                 else c_srange(self.arg)),
                    Call_slot srange(self.selector),
                    Call_table any,
                    Call_array (if (self.test = float) float else any),
                    Definition object,
                    to_C self.set_arg,
                    to_protect c_sort(self.arg),
                    Update c_sort(self.value),
                    If psort(c_sort(self.arg) meet c_sort(self.other)),
                    Handle  psort(c_sort(self.arg) meet c_sort(self.other)),
                    Let c_sort(self.arg),
                    to_CL any,
                    Return  any,
                    List object,
                    Set object,
                    Tuple object,
                    Construct any,
                    Gassign  any,
                    Super any,
                    For any,
                    Exists (if (self.other = unknown) any else object),
                    Iteration object,
                    And boolean,
                    Or boolean,
                    While any,
                    Do c_sort(last(self.args)),
                    any error("[internal] c_sort is not implemented for ~S",
                              owner(self))),
       float float,
       any psort(c_type(self))) ]

// for the special compiler properties, we need to tell the sort of the optimized
// form
[selector_psort(self:Call) : class
  -> let p := self.selector in
       (if (p = mClaire/base! | p = mClaire/index!) integer
        else if (p = anyObject!) (self.args[1] as class)
        else if (p = object!) (self.args[2] as class)
        else any) ]


// ******************************************************************
// *    Part 3: c_status                                            *
// ******************************************************************


// this is one of the most important method. c_status(x,l) returns the status bitvector
// associated to the method defined by the body x and whose variable list is l.
// It computes (using the code BEFORE optimization) the status of the 6 important flags
// NEW_ALLOC :       a new allocation may be done by running the method
// LIST_UPDATE :     a list is updated whose content is not gcsafe
// SLOT_UPDATE :     an slot is updated whose content is not gcsafe
// RETURN_ARG :      the result is (may be) one of the input argument (or a slot from ...) // v3.3.3
// SAFE_RESULT :     the result from the method (not gcsafe) does not need protection
// SAFE_GC :         the arguments do not need protection (even if an alloc occurs) -the method
//                   takes care of its arguments (pushed on a stack for instance)
// STRING_UPDATE     a string is modified (forbiden by C++ if const char) -> a copy is required  // v3.3.46
// this method is allowed to be pessimistic as far as allocation are concerned
[c_status(self:any,l:list) : integer
 -> case self
      (Instruction case self
            (Variable
               (if (unknown?(range, self) | not(gcsafe?(self.range)))
                  (if (self % l) bit_vector(RETURN_ARG)
                   else if (known?(range,self) & self.range <= float) bit_vector(NEW_ALLOC)
                   else 0)
                else bit_vector(SAFE_RESULT)),
             Error bit_vector(SAFE_RESULT),
             Printf c_return(0, c_or(list{c_status(x,l) | x in self.args})),
             Construct bit_vector(NEW_ALLOC),
             Definition bit_vector(NEW_ALLOC),
             Call let r1 := c_status_call(self.selector,c_type(l[1])),              // v3.3.48
                      r2 := c_or(list{c_status(x,l) | x in self.args}) in
                    c_return(r1,r2),                                 
             If let r1 := c_status(get(arg, self), l),
                    r2 := c_status(get(other, self), l) in
               c_return(c_or(r1,r2),c_status(self.test, l)),
             Do let y := last(self.args), r1 := c_status(y, l),
                    r2 := c_or(list{c_status(x, l) | x in self.args but y}) in
                 c_return(r1,r2),
             For c_return( c_status(self.arg,l), c_status(self.set_arg, l)),
             Iteration c_return(bit_vector(NEW_ALLOC), c_status(self.arg,l)),
             Let c_return(c_status(self.arg, l),
                          c_status(get(value, self), l)),
             Assign c_status(get(arg, self), l),
             Gassign c_status(get(arg, self), l),
             And c_return(0,c_or(list{c_status(x, l) | x in self.args})),
             Or c_return(0,c_or(list{c_status(x, l) | x in self.args})),
             Cast c_status(self.arg, l),
             Super let r1 := c_status_call(self.selector,self.cast_to),
                       r2 := c_or(list{c_status(x,l) | x in self.args}) in
                    c_return(r1,r2),
             Case c_or(list{c_status(x, l) | x in self.args}),
             While c_return(c_status(self.arg, l),c_status(self.test, l)),
             Return c_status(self.arg, l),
             Handle c_return(c_or(c_status(self.arg, l), c_status(self.other, l)),
                             c_status(self.test, l)),
             unbound_symbol 0,
             any Cerror("[internal] oops .. I forgot ~S",owner(self))),
       float bit_vector(NEW_ALLOC),
       string bit_vector(NEW_ALLOC),
       function bit_vector(NEW_ALLOC),
       Type bit_vector(NEW_ALLOC),
       any 0) ]

// this methods combines two status vector, assuming that the result could be
// one or the other
// note that the semantic for the SAFE_RESULT flag is an and (both must be safe)
// v3.4 same for RETURN_ARG : the semantic is an and
[c_or(x:integer,y:integer) : integer
 -> let d := (x or y) in
     (if ( d[SAFE_RESULT] & not(x[SAFE_RESULT] & y[SAFE_RESULT])) d :- ^2(SAFE_RESULT),
      if ( d[SAFE_GC] & not(x[SAFE_GC] & y[SAFE_GC])) d :- ^2(SAFE_GC),
      if ( d[RETURN_ARG] & not(x[RETURN_ARG] & y[RETURN_ARG])) d :- ^2(RETURN_ARG),   // v3.4
      d)  ]


[c_or(l:list) : integer
 => let d := 0 in (for x in l d := c_or(d,x), d) ]

// computes the status of a method if unknown. We use the c_status method to
// compute a bitvector
[Compile/status!(self:restriction) : integer
 -> case self
      (method (if known?(status, self) self.status
               else if unknown?(formula, self)
                 (write(status, self, 0), 0)
               else (self.status := 0,
                     self.status := c_status(self.formula.body,
                                             self.formula.vars),
                     //[4] status(~S) = ~S // self,self.status,
                     self.status)),
       any 0) ]


// this is a special version where only x may be returned, thus dominates the
// two result flags
[c_return(x:integer,y:integer) : integer
-> let d := (x or y) in
     (if ( not(x[SAFE_RESULT]) & y[SAFE_RESULT]) d :- ^2(SAFE_RESULT),
      if ( not(x[RETURN_ARG]) & y[RETURN_ARG]) d :- ^2(RETURN_ARG),
      d)  ]

// computes the status vector associated to a property
// v3.3.38: use the type of the first argument to filter out restrictions that are irrelevant
[c_status_call(self:property,t:type) : integer
 -> let r := (if stable?(self) 0 else bit_vector(NEW_ALLOC,BAG_UPDATE,SLOT_UPDATE)) in
      (for x in self.restrictions
        (if (t glb x.domain[1])
             case x (method (if not(last(x.srange) % {integer,any,object,void})
                                r := c_or(r,bit_vector(NEW_ALLOC)),                // return value may require an allocation
                             r := c_or(r,status!(x))),
                     slot r := c_or(r,^2(RETURN_ARG)))),  // v3.3.3 : return x.r is same as return x as far as GC protection is concerned
       r) ]

// here we fix some status by hand
(write(Core/status, Core/vmatch? @ any, bit_vector(SAFE_GC)),
 write(Core/status, Core/pop_debug @ property, 0),
 write(Core/status, Core/matching? @ list, bit_vector(SAFE_GC)),
 write(Core/status, Core/eval_message @ property, bit_vector(NEW_ALLOC,SLOT_UPDATE,SAFE_GC)),
 write(Core/status, nth @ bag, bit_vector(RETURN_ARG)),   // v3.3.3 returning a part of a list is like a slot of an object !
 write(Core/status, eval @ any, bit_vector(NEW_ALLOC)),
 write(Core/status, self_eval @ Call, bit_vector(SAFE_GC)),
 write(Core/status, self_eval @ If, bit_vector(SAFE_GC)),
 write(Core/status, self_eval @ Do, bit_vector(SAFE_GC)),
 write(Core/status, nth= @ string, bit_vector(STRING_UPDATE)),
 write(Core/status, nth_put @ string, bit_vector(STRING_UPDATE)))   // v3.3.46


// useful #1: show a status
[claire/showstatus(m:method) : any
  -> let l1 := list("NEW_ALLOC","BAG_UPDATE","SLOT_UPDATE","RETURN_ARG","SAFE_RESULT","SAFE_GC","STRING_UPDATE"),
         l := list<any>(), s := Core/status(m) in
       (for i in (1 .. 7) (if s[i] l :add l1[i]), l) ]

// useful #2: provoke a recomputation of status
[claire/s_test(m:method) : void
  -> let  la := m.formula,
          news := c_status(la.body,la.vars) in
       (//[0] status(~S) := ~S // m, news,
        Core/status(m) := news,
        showstatus(m)) ]

// ******************************************************************
// *    Part 4: Names & identifiers management                      *
// ******************************************************************

// check that the module is allowed and otherwise complain because of x;
// this should raise an error, it simply returns false if there is a problem
[legal?(self:module,x:any) : boolean
 -> if (x = object! | x = anyObject!) true
    else if (OPT.legal_modules)
       (if (not(self % OPT.legal_modules)  &
            (case x (method (x.inline? = false | not(compiler.inline?)))))
        (trace(0, "legal_modules = ~S\n", OPT.legal_modules),
         trace(0, "---- ERROR: ~S implies using ~S !\n\n", x, self),
         false)
        else true)
     else (need_modules(OPT) :add self, true) ]

legal?(self:environment,x:any) : any -> true

// A named object is used, thus it must be declared if it belongs to the
// current module - returns true if OK
[c_register(self:(thing U class)) : any
 -> let x := get_module(self) in
       (if (x != system) legal?(x, self) else true) ]

// looks if a property may be implicit and then add it in the right list
[c_register(self:property) : any
 -> let m := module!(), m2 := get_module(self) in
     (// while (m.loaded = 0) m := m.part_of,     // <yc> 7/98: we need the compilation unit
      if ((m2 = claire | m2 = m) & //   v3.2.4  (self % property) &
          not(self % OPT.objects)) //   v3.2.4  & not(self % OPT.properties))
        OPT.properties :add self,
      c_register@thing(self)) ]

// declare the property as used and check if a property may allocate
[selector_register(self:property) : any
 ->  c_register(self),
     if (allocate?(self) = true) OPT.allocation := true,
     self ]

// looks if a property may cause an allocation
[allocate?(self:property) : any
 ->  for x in self.restrictions
       case x
        (slot (if (not(gcsafe?(x.range)) & srange(x) != any) break(true)
              else if (not(gcsafe?(x.range)) & not(gcsafe?(domain!(x))))
                 break(0)),
         method (if (status!(x)[NEW_ALLOC] |
                      not(c_srange(x) % {any,integer,object}) |
                     not(gcsafe?(x.range))) break(true))) ]

// this method looks if the open slot is less than 1 or can be set to 1
// v3.3.48 note - weaken the open semantic to get a better c_status
[stable?(self:relation) : boolean
 -> let m := get_module(self) in
       (if (self.open = 2) // v3.3.48  - was :  & (m % OPT.legal_modules | m = system))
           write(open, self, 1)),
     self.open <= 1 | self.open = 4 ]                       // v3.2.04

// returns the module (i.e. the compilation unit, not the namespace) in which self is
// defined
[get_module(self:(thing U class)) : any
  -> defined(self.name) ]
//      (while (m.loaded = 0) m := m.part_of, m) ]


// allows to optimize the access
[known!(l:listargs) : any
 -> (to_remove(OPT) :add known!,
     for r in l (case r (property OPT.knowns :add r))) ]


// ******************************************************************
// *    Part 5: On-line optimization                                *
// ******************************************************************


// a cute method that optimises all methods
oload(m:module) : any -> (load(m), turbo(m))
oload(f:string) : any -> (load(f), turbo(module!()))

[turbo(m:module) : any
 -> let vb := system.verbose in
       (OPT.online? := true,
        verbose() := 0,
        for x:method in method
          (if (x.module! = m & not(x.inline?) & known?(formula, x))
              let l := x.formula,
                  y := l.body in
                try (if (x.range = any) write(range, x, c_type(y)),
                     write(body, l, c_code(y, any)),
                     *variable_index* := length(l.vars) + 1,
                     write(body, l,
                           Language/lexical_build(l.body, l.vars, *variable_index*)),
                     write(dimension, l, *variable_index*))
                catch any (write(body, l, y), nil)),
        OPT.online? := false,
        verbose() := vb,
        true) ]

// prints the optimisation stats - todo
[stats(x:meta_OPT) : void -> nil]


//+-------------------------------------------------------------+
//| CLAIRE                                                      |
//| otool.cl                                                    |
//| Copyright (C) 1994 - 2013 Yves Caseau. All Rights Reserved  |
//| cf. copyright info in file object.cl: about()               |
//+-------------------------------------------------------------+

//-------------------------------------------------------------------
// this file contains the auxiliairy methods for the source optimizer
//-----------------------------------------------------------------

// ******************************************************************
// *  Table of contents                                             *
// *    Part 1: New Instructions & associated stuff                 *
// *    Part 2: Optimizer Warnings                                  *
// *    Part 3: Type Handling                                       *
// *    Part 4: Garbage Collection functions                        *
// *    Part 5: Miscellaneous                                       *
// ******************************************************************

// ******************************************************************
// *    Part 1: New Instructions & associated stuff                 *
// ******************************************************************

// three special instructions

// we will need it for GC protection
self_print(x:Compile/to_protect) : void
 -> printf("[to_protect ~S]", x.arg)
self_eval(x:Compile/to_protect) : any -> eval(x.arg)

// to_CL(x,s) produces a CLAIRE oid from an external thing of sort s
self_print(self:Compile/to_CL) : void -> printf("CL{~S}:~S", self.arg,self.set_arg)

c_type(self:Compile/to_CL) : type
 -> sort_abstract!(c_type(get(arg, self)))   // v2.4.06 (was any)

Compile/c_gc?(self:Compile/to_CL) : boolean
 -> (not(gcsafe?(self.set_arg)) &
      (self.set_arg = float |                  // v3.3.3 ! float must be protected when converted to OID
       self.set_arg Core/<=t import) |         // v3.00.10: similar rule = protect import if converted to OID
       Compile/c_gc?(self.arg))                // default: only protect if content if GC-fragile 
     

// to_C(x) produces an external thing from a CLAIRE oid of sort s.
self_print(self:Compile/to_C) : void -> printf("C{~S}:~S", self.arg,self.set_arg)

// new: (to retrofit in v2.5) an object pointer may be dangerous
Compile/c_gc?(self:Compile/to_C) : boolean
  -> (not(gcsafe?(self.set_arg)) & Compile/c_gc?(self.arg) &
      (self.set_arg Core/<=t object | self.set_arg = string) )      // v3.00.30 !! + v3.3.34

[c_type(self:Compile/to_C) : type
 -> self.set_arg glb ptype(c_type(get(arg, self))) ]                 // v3.2.28 (smart)

// this is a same-sort (object) casting from one class to another because of the
// stupidity of the target type system
// its use is linked to stupid_t(x)
self_print(self:Compile/C_cast) : void
 -> printf("<~S:~S>", self.arg, self.set_arg)
Compile/c_gc?(self:Compile/C_cast) : boolean -> Compile/c_gc?(self.arg)
c_type(self:C_cast) : type -> self.set_arg    // v3.0 : better safe
c_code(self:Compile/C_cast,s:class) : any
 -> (if (s inherit? object)
        Compile/C_cast(arg = c_code(self.arg, s), set_arg = self.set_arg)
     else c_code(self.arg, s))

// we need a new type to express powerful Iterate rules
// Note: Patterns require the compiler !

self_print(self:Pattern) : void
 -> printf("~S[tuple(~A)]", self.selector, self.arg)

%(x:any,y:Pattern) : boolean
 -> (case x
      (Call (x.selector = y.selector &
             tmatch?(list{ c_type(z) | z in x.args}, y.arg)),
       any false))

//^(x:Pattern,y:any) : type -> {}
glb(x:Pattern,y:type) : type -> {}
[less?(x:Pattern,y:any) : boolean
 -> case y
      (Pattern (x.selector = y.selector & length(x.arg) = length(y.arg) &        // v3.2.18
                forall(i in (1 .. length(x.arg)) | =type?(x.arg[i],y.arg[i]))),
       any Call Core/<=t y) ]

[less?(x:any, y:Pattern) : boolean
 ->  case x
      (Pattern (x.selector = y.selector & length(x.arg) = length(y.arg) &
                forall(i in (1 .. length(x.arg)) | =type?(x.arg[i],y.arg[i]))),
       any false) ]

// v0.03 must return a type
nth(p:property,x:tuple) : Pattern -> Pattern(selector = p, arg = list!(x))

// use specially marked union for extended types X U {unknown}
optUnion <: Union

// ******************************************************************
// *    Part 2: Optimizer Warnings                                  *
// ******************************************************************

// unified warning
Compile/warn()  : void
 -> (if known?(OPT.in_method) trace(2,"---- WARNING[in ~S]: ",OPT.in_method)
     else trace(2,"---- WARNING: "))

Compile/Cerror(s:string,l:listargs) : {}
  -> (printf("---- Compiler Error[in ~S]:\n", OPT.in_method),
      printf("---- file read up to line ~A\n", Reader/nb_line(reader)),
      general_error(Core/cause = s, arg = l))

// a note
Compile/notice() : void
 -> (if known?(OPT.in_method) trace(3,"---- note[in ~S]: ",OPT.in_method)
     else trace(3,"---- note: "))

// Warning : compiling is impossible, wrong selector
[c_warn(self:Call,%type:any) : any
 -> let s := self.selector in
       (if (%type = void)  Cerror("[205] message ~S sent to void object", self)
        else if (not(s.restrictions) & not(s % OPT.ignore))
           (warn(),trace(2,"the property ~S is undefined [255]\n", s))
        else if (not(s % OPT.ignore) & (s.open <= 1 | s.open = 4) &
                 (case %type (list class!(%type[1]).open != 3)))
            (warn(), trace(2,"wrongly typed message ~S (~S) [256]\n", self, %type))
        else if compiler.optimize?
            (notice(), trace(3,"poorly typed message ~S [~S]\n", self, %type)),   // v3.3 poor opt. notice
        open_message(self.selector, self.args)) ]

[c_warn(self:Super,%type:any) : any
 -> let s := self.selector in
       (if (%type = void)  Cerror("[205] message ~S sent to void object", self)
        else if not(s.restrictions)
           (warn(),trace(2, "the property ~S is undefined [255]\n", s))
        else if (not(s % OPT.ignore) & s.open <= 1)
           trace(3,"---- note: wrongly typed message ~S [~S]\n", self, %type),
        let m := open_message(self.selector, self.args) in
          Super(selector = m.selector, cast_to = self.cast_to, args = m.args))  ]

// a message cannot be compiled into efficient code
// here the property does not allow the compilation and we want to see it
[c_warn(self:property,l:list,%type:list) : any
 -> if (self.open <= 1 & not(self % OPT.ignore) &  compiler.safety > 1)
        trace(4, "---- note: poor type matching with ~S(~S) [~S]\n", self, l, %type),
    open_message(self, l) ]

// a variable should not be abused ! Either it is a true error or it is
// simply dangerous. The result is the value to be used (either x or
// ckeck_in(x,range(oself))
[c_warn(self:Variable,x:any,y:type) : any
 -> if not(y ^ self.range)
        (if (compiler.safety > 4)
            (warn(), trace(2,"~S of type ~S is put in the variable ~S:~S [257]\n",
                            x, y, self, self.range))
         else Cerror("[212] the value ~S of type ~S cannot be placed in the variable ~S:~S",
                    x, y, self, self.range))
     else if (compiler.safety <= 1 |
              not(sort=(osort(self.range), osort(y))))
        (warn(),trace(2,"~S of type ~S is put in the variable ~S:~S [257]\n",
                      x, y, self, self.range)),
     if (compiler.safety <= 1 & not(y <= self.range))
        c_check(c_code(x, any), c_code(self.range, type))
     else x ]


// ******************************************************************
// *    Part 3: Type Handling                                       *
// ******************************************************************

// we use  {any U type} to represent the change of sort  (to any)
//         {} U (c U t) to represent a change of psort   (to c)
// e.g.: (any U class) = class stored as an OID

 // tests if two sorts are similar
Compile/sort=(c:class,c2:class) : any
 -> (if (c inherit? object) c2 inherit? object
     else (c = c2 |
          (not(compiler.overflow?)
           & (c = any & c2 = integer) | (c = integer & c2 = any))))

// give the "precise sort", i.e., a class under object is a sort
[Compile/psort(x:any) : class
 -> let c := class!(x) in
      (if (c inherit? object) c
       else if (c = float) c
       else sort!(c)) ]

// gives the "optimizer sort", which is one of
// any, object, float, X <= import,
[Compile/osort(x:any) : class
 -> let c := class!(x) in
      (if (c = float) c else sort!(c)) ]

sort(x:Variable) : class
 -> (let r := x.range in
       (if (case r (Union r.Core/t1 = {}))
           Compile/psort(r.Core/t2.Core/t2)
        else Compile/psort(r)))

// this is a very stupid type inference that mimicks the C compiler
// it returns a sort
[Compile/stupid_t(self:any) : class
 -> case self
      (Variable let r := self.range in
                  (if sort_abstract?(r) any
                   else if (case r (Union r.Core/t1 = {}))
                      r.Core/t2.Core/t1 as class
                   else class!(r)),
       global_variable let r := self.range in                          // was missing ! v3.0.62
                         (if r class!(r) else owner(self.value)),
       And boolean,
       bag owner(self),
       environment environment,
       class class,
       Call_slot let s := self.selector, p := s.selector in
                   (for s2 in p.mClaire/definition
                      (case s2 (slot (if (domain!(s) <= domain!(s2)) s := s2))),      // v3.2.30 C++ is really stupid :-)
                    class!(s.range)),
       Call_method class!(self.arg.range),
       Call selector_psort(self),
       to_C self.set_arg,
       to_protect stupid_t(self.arg),
       symbol owner(self),
       char owner(self),
       boolean owner(self),
       primitive owner(self),
       Assign stupid_t(self.arg),
       Let stupid_t(self.arg),
       Do Compile/stupid_t(last(self.args)),
       If Compile/stupid_t(self.arg) meet Compile/stupid_t(self.other),
       Collect list,
       Image set,
       Or boolean,
       Select set,
       Lselect list,
       List list,
       Set set,
       thing owner(self),
       Tuple tuple,
       Exists (if (self.other = unknown) any else boolean),
       integer integer,
       any any) ]

// comparison
[Compile/stupid_t(self:any,x:any) : boolean
 ->  let c1 := Compile/stupid_t(self),
         c2 := Compile/stupid_t(x) in
       (c1 != any & c1 = c2) ]

// an extended type is of the kind (t U {unknown})
[extended?(self:type) : boolean
 -> case self
      (Union (self.Core/t2 % set & self.Core/t2 & self.Core/t2[1] = unknown),
       any false) ]

// creates an extended  (v0.02) that can be checked easily (use optUnion)
[extends(x:type) : type
   -> optUnion(Core/t1 = x, Core/t2 = {unknown})]

// a sort abstraction is the special union any U t, which is known to represent t by
// the type system (used for variables only) but tells the compiler that the sort is any
[sort_abstract!(x:type) : type
  -> if ((sort!(x) != any & (sort!(x) != integer | compiler.overflow? )) |
         x = float)
        Union(Core/t1 = any, Core/t2 = x)        // sort! on float is special..
     else x ]                                                                                          // v3.00.05
sort_abstract?(x:type) : boolean -> (case x (Union (x.Core/t1 = any), any false))

// since we introduce some fuzziness with types (any U t), we need a way to get
// the precise type t back
ptype(x:type) : type
 -> (case x (Union (if (x.Core/t1 = any) x.Core/t2 else x), any x))

// v3.1.06: member -> always apply to a ptype
pmember(x:type) : type -> member(ptype(x))

// transform an instruction representing a set into an instruction
// representing an enumeration
[enumerate_code(self:any,%t:type) : any
 -> if (ptype(%t) <= bag) c_strict_code(self, bag)              // v3.2.01
    else (if compiler.optimize? (notice(), trace(3,"explicit enmeration of ~S\n", self)),  // v3.3
          c_code_method(Core/enumerate @ any, list(self), list(%t))) ]


// range inference for a "for" structure: y is the new type and ts is the type of
// the collection structure. Note that except for the case of float arrays, the
// sort of the collection is assumed to be any or integer (thus we "correct" the
// type inference with sort_abstract)
[range_infers_for(self:Variable,y:type,ts:type) : any
 ->  if unknown?(range, self)
        (//[5] infer type ~S for ~S // y, self,
         if (y % Interval) y := integer,              // v3.1.06
         put(range, self, y))
     else if (not(y <= self.range) & compiler.safety <= 1)
        (if not((y & self.range))
            (warn(), trace(2, "range of variable in ~S is wrong [258]\n", self))),
        // v3.1.06: remove complains because it traps the compiler's own inferences
        // to reintroduce, we need to distinguish between user and compiler
        // types for iteration variables !
     if (sort(self) != any & (sort(self) != integer | compiler.overflow?) &
         not(ts <= array & y <= float))               // iteration of float array is a special case
       (//[5] protect original sort with ~S // sort_abstract!(self.range),
        put(range, self, sort_abstract!(self.range))) ]


// variable range inference, how to guess a type from the value ...
[range_infers(self:Variable,y:type) : any
 ->  gc_register(self),
     if (unknown?(range, self) | (extended?(self.range) & self.range % optUnion))
        (if (y % set) put(range, self, class!(y))
         else put(range, self, y)) ]

// temporary range inference for case, which may use a special form:
// {any U type} to represent the change of sort
// {} U (c U t) to represent a change of psort
[range_infer_case(self:any,y:type) : void
 -> case self
      (Variable (if sort=(osort(self.range), osort(y))
                   let c1 := psort(class!(self.range)) in
                     (if (c1 != psort(class!(y)))
                         put(range, self,
                             Union(Core/t1 = {},
                                   Core/t2 = Union(Core/t1 = c1, Core/t2 = y)))
                      else put(range, self, y))
                else if (osort(self.range) = any)
                   put(range, self, sort_abstract!(y)))) ]

// create a protected assignment
[c_check(x:any,y:any) : any
 -> let m := (check_in @ any) in
       (if (compiler.safety > 3) x
        else (legal?(m.module!, m),
              Call_method2(arg = m, args = list(c_gc!(x), c_gc!(y))))) ]

// temporary range inference for case, which may use a special form:
// {any U type} to represent the change of sort
// {} U (c U t) to represent a change of psort
[range_sets(self:any,y:type) : void
 -> case self
      (Variable (if sort=(osort(self.range), osort(y))
                   let c1 := psort(class!(self.range)) in
                     (if (c1 != psort(class!(y)))
                         put(range, self,
                             Union(Core/t1 = {},
                                   Core/t2 =  Union(Core/t1 = c1, Core/t2 = y)))
                      else put(range, self, y))
                 else if (osort(self.range) = any)
                   put(range, self, sort_abstract!(y)))) ]

// the srange of a method may be tricky because of float method
[Compile/c_srange(m:method) : class
  -> if (m.range = float) float else (last(m.srange) as class) ]

// v3.3 some of the global variables are compiled with a native var approach
// we require the range to be safe, no backtrack & local global var
[Compile/nativeVar?(x:global_variable) : boolean
  -> (compiler.optimize? & x.Core/store? = false &              // v3.3.04: only when optimized
      x.name.module! = x.name.mClaire/definition & gcsafe?(x.range)) ]

// v3.3 finds the possible return type of a block (within a loop)
// it returns a class for the time being ...
[Compile/return_type(self:any) : type
 -> case self
      (to_C return_type(self.arg),
       to_protect return_type(self.arg),
       Let return_type(self.arg),
       Do let x := {} in (for y in self.args x :^ return_type(y), x),
       If return_type(self.arg) ^ return_type(self.other),
       Return c_type(self.arg),
       Case let x := {} in (for y in self.args x :^ return_type(y), x),
       Handle return_type(self.arg),
       any {}) ]


// compiling a type expression --------------------------------------------
//
// creates the functional code that produce the code by evaluation
// note this is expensive -> we should encourage the use of global variables

c_code(self:Type,s:class) : any -> c_code(self_code(self), s)


// to check - seems OK for 3.2 !
[self_code(self:subtype) : any
 -> Call(nth, list(self.arg, c_code(self.Kernel/t1,type)))]

// create a Param. Optimized in v3.2.28 for list<X>
[self_code(self:Param) : any
 -> if  (length(self.params) = 1 &  self.params[1] = of & self.args[1] % set)
        Call(Core/param!, list(self.arg, c_code((self.args[1])[1],type)))
    else Call(nth, list(self.arg, self.params,
                        list{c_code(y,type) | y in self.args})) ]

[self_code(self:Union) : any
 ->  Call(U,list( c_code(self.Core/t1,type), c_code(self.Core/t2,type))) ]

[self_code(self:Interval) : any
 -> Call(..,list(self.arg1,self.arg2)) ]

[self_code(self:Reference) : any
 -> Definition(arg = Reference,
               args = list(Call(=,  list(args, self.args)),
                           Call(=,  list(Kernel/index, self.Kernel/index)),
                           Call(=,  list(arg, self.arg)))) ]

// compilation of a Pattern
self_code(self:Pattern) : any
 -> (if compiler.inline?
        Call(nth, list(self.selector,Tuple(args = self.arg)))
                    //      Call(tuple!, list(List(args = self.arg)))))
     else Call)


//-------------- membership compiling -------------------------------

[member_code(self:class,x:any) : any
 -> let %xt := Call((if (c_type(x) <= object) isa else owner),list(x)) in
         (if ((self.open <= -1 | self.open = 1) & not(self.subclass))
              c_code(Call(=, list(self,%xt)))
          else c_code(Call(inherit?, list(%xt, self)))) ]

[member_code(self:Type,x:any) : any
 -> Call_method2(arg = (% @ list(any,any)),
                 args = list(c_code(x, any), c_code(self, any))) ]

[member_code(self:Union,x:any) : any
 -> Or(args = list(member_code(self.Core/t1, x),
                   member_code(self.Core/t2, x))) ]

[member_code(self:Interval,x:any) : any
 -> c_code(And(args = list(Call( >=, list(x, self.Core/arg1)),
                           Call( <=, list(x, self.Core/arg2)))),
           any) ]

[member_code(self:Param,x:any) : any
 -> c_code(And(args =
                 (list(Call(%, list(x, self.arg))) /+
                  list{ Call( %, list(Call(self.params[i],list(x)),self.args[i])) |
                        i in (1 .. length(self.params))})),
           any)]

// v3.3.14: specialized code for tuple
[member_code(self:tuple,x:any) : any
 -> if (x % Tuple)
       (if (length(x.args) != length(self)) false
        else c_code(And(args = list{Call(%, list(x.args[i], self[i]))  |
                                    i in (1 .. length(self)) }), any))
    else c_code_method(% @ list(any,any), list(x,self), list(any,any)) ]



[member_code(self:any,x:any) : any
 -> LDEF := nil,
    let %type := list(c_type(x), c_type(self)),
         r := Language/extract_pattern(self, nil) in
       (if (r = unknown | self = object | (case self (global_variable self.range))) // 2.4.06
           c_code_method(% @ %type, list(x, self), %type)
        else member_code(r, x)) ]

// membership optimization though inline definition of %
%(x:any,y:..[tuple(any, any)]) : boolean
 => (x <= eval(y.args[2]) & eval(y.args[1]) <= x)

%(x:any,y:but[tuple(any, any)]) : boolean
 => (x % eval(y.args[1]) & x != eval(y.args[2]))

// ******************************************************************
// *    Part 4: Garbage Collection functions                        *
// ******************************************************************

// says if an object of this type has to be protected from the GC
[gcsafe?(self:class) : boolean
 -> (self = void | self inherit? thing | self inherit? class |
     (self != object & self inherit? object & self.open < 3 & not(self inherit? collection) &
      self != lambda) |
     self = integer | self = char | self inherit? boolean |
     self = function)]

[gcsafe?(self:type) : boolean
 ->  case self
      ({{}} true,
       Union (gcsafe?(self.Core/t1) & gcsafe?(self.Core/t2)),
       any gcsafe?(class!(self))) ]

// says is a property is gcsafe?
[gcsafe?(self:property) : boolean
 -> forall(x in self.restrictions | gcsafe?(self.range)) ]

// create a to_protect structure / if_needed
// notice that the to_protect can later be invalidated by need_protect, called in cexp.cl
[c_gc!(self:any) : any
 -> if (not(OPT.online?) & c_gc?(self))
        (// [4] ---- note: use GC protection on ~S // self,
         OPT.protection := true,
         to_protect(arg = self))
     else self ]

// create a to_protect structure / if_needed
// notice that the let is special because the variable may be protected through a GC_PUSH
// that will become invalid in a loop (new in 2.3.06)
[c_gc!(self:any,t:type) : any
 -> if (not(OPT.online?) & (c_gc?(self) |
                         self % Let & not(gcsafe?(c_type(self))))  // <yc> 31/10/98
         & not(gcsafe?(t)))
        (// [4] ---- note: use GC protection on ~S // self,
         write(protection, OPT, true),
         to_protect(arg = self))
     else self ]

// tells if a Call_slot or a nth needs a protect
// which means: we read a value that can be modified later
[Compile/need_protect(x:any) : boolean
 -> case x
      (Call_slot OPT.use_update,
       Call_method2 (if (x.arg.selector = nth)
                        (OPT.use_nth= |                         // if use_nth ... we must protect
                         domain!(x.arg) = class |               // type expression
                         c_type(x.args[1]) <= tuple)            // tuple may be stack-allocated
                     else true),                               // v3.3.32 ! default is true here !!!
        any true) ]

// ******************************************************************
// *    Part 5: Miscellaneous                                       *
// ******************************************************************

// ------- variables ------------------------------------------------

Compile/Variable!(s:symbol,n:integer,t:type) : Variable
 -> Variable(Core/pname = s, Kernel/index = n, range = t)

get_indexed(c:class) : list -> c.slots

// simple C operations that can be duplicated at no cost
// *simple_operations*:set :: {+, -, /, *}

// tells if an expression is a C simply designated object
[designated?(self:any) : boolean
 ->  self % thing | self % Variable | self % integer | self % boolean |
     self = nil | self = {} | self = unknown | self % float |
     (case self
       (Call let x := c_code(self) in
               ((not(x % Call) & designated?(x)) |
                 self.selector = mClaire/get_stack),
        Call_slot designated?(self.arg),
        Call_table designated?(self.arg),
        to_protect (not(need_protect(self.arg)) & designated?(self.arg)),
        Call_method ((self.arg.selector % OPT.simple_operations |
                     (self.arg = (nth @ bag))) &    // v3.2.34: added nth
                    forall( y in self.args | designated?(y))),
        to_CL designated?(self.arg),
        to_C designated?(self.arg),
        any false)) ]




// registers the adress of the variable that may be used.
[gc_register(self:Variable) : any
 -> if (OPT.loop_index >= 0 & self.index > OPT.loop_index)
       OPT.loop_index := self.index,
    true ]

// v3.0.70 from v2.5.52: use inner2outer
gc_register(self:Variable,arg:any) : any
  -> (//[5] .... CALL REGISTER ON ~S := ~S // self,arg,
      if inner2outer?(arg) gc_register(self))

// new in v2.5.52
// we register if we may use the index: either the value is protected or
// it may be a reference to the content (x) of an inner variable that is placed
// in an outer one !
// v3.3.26: if the value is passed through a method that return its arg which is itself protected
// v3.3.36: the value is an allocation that is protected by a GC_PUSH done at the kernel level
// v3.3.38: copy @ bag is of the same kind (more expected)
// (for instance, a list allocation
Compile/inner2outer?(x:any) : boolean
  -> (case x
      (to_protect true,                              // this is strange
       Variable not(Optimize/gcsafe?(x.range)),
       Call_method 
          ((x.arg.selector = copy & x.arg.range = bag) |           // v3.3.38
           (x.arg.status[RETURN_ARG] & inner2outer?(x.args[1]))),  // v3.3.26
       to_CL inner2outer?(x.arg),
       to_C  inner2outer?(x.arg),
       List true, Set true,                          // v3.3.36
       Let inner2outer?(x.var)))


// those sets who are identifiable
// v3.1.12 : reverse semantics => list of exception
// v3.2.50 : this must be modifiable !
;*non_identifiable_set*:set ::
;  Id(set<class>{c in class | exists(c2 in c.descendents | c2.ident? = false)})

// equality is identity?
[Compile/identifiable?(self:any) : boolean
 -> (self = unknown |
      (case self (to_CL identifiable?(arg(self)),
                  any (let t := class!(c_type(self)) in
                         not(t % OPT.non_identifiable_set))))) ]

// inlinning ---------------------------------------------------------

// macro expansion
[c_inline(self:method,l:list,s:class) : any
 -> //[5] macroexpansion of ~S with method ~S // l,self,
    c_code(c_inline(self, l), s) ]
    
// apply the body of a macro definition
// notice that the name of the inner variables is changed except the second variable
// of iterate macros    
[c_inline(self:method,l:list) : any
 -> let f := self.formula,
        x := f.body,
        lbv := bound_variables(x),
        pv0 := (if (self.selector % {iterate, Iterate}) f.vars[2].pname
                else class.name) in
       (x := Language/instruction_copy(x),
        //[5] c_inline(~S) on ~S: ~S is bound : ~S // self,l,lbv,x,
        for v in lbv
          let v2 := Variable(pname = (if (v.pname = pv0) pv0
                                      else gensym()),     // v3.2.01, was (n :+ 1, v.pname /+ "_C_" /+ string!(n))),
                             Kernel/index = 1000) in      // force to be a local !
           (put(range,v2, get(range, v)),
            x := Language/substitution(x, v, v2)),
        OPT.max_vars :+ length(lbv),
        c_substitution(x, f.vars, l, false)) ]


// returns the macro expanded code if a macro is involved and nil otherwise
[c_inline_arg?(self:any) : any
 -> case self
      (Call let l := self.args,
                m := restriction!(self.selector, list{ c_type(x) | x in l}, true) in
              case m
               (method (if (m.inline? & c_inline?(m, l)) c_inline(m, l)),
                any nil),
       any c_inline_arg?(Call(selector = set!, args = list(self)))) ]

// substitute any variable with same name as x with the value val. val is an expression
// when the special form eval() is found, it is "evaluated"
// NEW: in v3.0.5 -> eval(x,C) evals only if x is actually a C
[c_substitution(self:any,lx:list[Variable],val:list,eval?:boolean) : any
 ->  case self
      (Variable let i := some(j in (1 .. length(lx)) |
                              self.Core/pname = lx[j].Core/pname) in
                  (if known?(i) val[i] else self),
       bag (for i in (1 .. length(self))
              self[i] := c_substitution(self[i], lx, val, eval?),
            self),
       Call (if (self.selector = eval)                     // two patterns eval(e) or eval(e,R)
               c_substitution(self.args[1], lx, val,       // new in v3.0.5 !
                              (length(self.args) = 1 |     // bool = true means
                                 (length(self.args) = 2 &  // we evaluate !
                                  val[1] % self.args[2]))) // 3.2.56: the range test holds on the first arg
             else if eval?
               try apply(self.selector,
                         list{ c_substitution(y, lx, val, true) |
                           y in self.args})
               catch any
                 (//[0] a strange problem happens ~A // verbose(),
                  warn(),trace(2,"failed substitution: ~S",system.exception!),
                  c_substitution(self.args, lx, val, false), self)
          else (c_substitution(self.args, lx, val, false), self)),
       Instruction (for s in owner(self).slots
                      let y := get(s, self) in
                        put(s, self, c_substitution(y, lx, val, eval?)),
                    self),
       any self) ]

// needed
[eval(x:any,y:class) : any -> eval(x) ]

// returns the list of bound variables in a piece of code
[bound_variables(self:any) : list
 -> let l := list<any>() in
       (case self (Instruction_with_var l := list<any>((self as For).var)),
        case self
         (Variable nil,
          Instruction for s in self.isa.slots
                       l :add* bound_variables(get(s, self)),
          bag for x in self l :add* bound_variables(x)),
        l) ]

// we must recognize true boolean ! coercion
[c_boolean(x:any) : any
  -> let tx:type := c_type(x), ptx:type := ptype(tx) in
       (if (ptx <= boolean)
           (case x (Call (if (x.selector = not & (ptype(c_type(x.args[1])) != boolean))
                             x := Call(!=,list(Call(boolean!,list(x.args[1])),true)))),
            (if (tx <= boolean) c_strict_code(x,boolean)
             else c_code(x,boolean)))      // v3.3
        else if (tx <= bag) c_code(Call(!=,list(Call(length,list(x)),0)))
        else c_code(Call(boolean!,list(x)))) ]





/***********************************************************************/
/**   compile CLAIRE                                    Yves Caseau    */
/**   readme.cl                                                        */
/**   Copyright (C) 1998-2013 Yves Caseau. All Rights Reserved.        */
/***********************************************************************/


This directory contains the files for two compiler modules: Optimize & Generate.
Optimize is the "target-code-independant" part of the compiler : from CLAIRE instruction
to optimized-claire-instruction.
Generate is the target code compiler, geared towards C++.
However, it has made generic so that other target languages may be plugged (see the JLight compiler
module as a Java example)


/****************/
/**  Optimize  **/
/****************/

CLAIRE instruction-to-instruction optimization is defined by a handful of methods:

  c_type(x)  is the CLAIRE type of x
  c_code(x)  is an optimized instruction
  & c_code(x,s) is an optimized expression of sort s
  c_gc?(x)   [boolean] true if x must be protected from garbage collection
  c_sort(x)  the sort of the expression x (precise sort)
  c_status(x,l) [bitvector] abstract interpretation of x according to a set
             of criterions (allocation, update, etc...)

The sort is a class sub-hierarchy which has an homogeneous way to be translated into the
target language. Here th sorts are integer, char, x <= imported, object, entity

osystem.cl      This file contains the gloabal parameter objects and the key methods: c_type, c_code, c_gc?, c_sort, c_status
otool.cl        This file contains the auxiliairy methods for the source optimizer
ocall.cl        this is the heart of the CLAIRE optimizer : message to function calls
ocontrol.cl     contains the optimizer for the control structures - most of them are replaced with simpler structures
                that may be translated directly into the target language
odefine.cl      optimization of the definition instruction -> sort-of macroexpansion

// ******************************************************************
// *   contents of osystem.cl                                       *
// *    Part 1: General Global Variables and Properties             *
// *    Part 2: The defaults for c_type, c_code, c_gc and c_sort    *
// *    Part 3: c_new, c_sort, c_fonc                               *
// *    Part 4: Names & identifiers management                      *
// *    Part 5: On-line optimization                                *
// ******************************************************************
// ******************************************************************
// *  contents of otool.cl                                          *
// *    Part 1: New Instructions & associated stuff                 *
// *    Part 2: Optimizer Warnings                                  *
// *    Part 3: Type Handling                                       *
// *    Part 4: Garbage Collection functions                        *
// *    Part 5: Miscellaneous                                       *
// ******************************************************************
// ******************************************************************
// *  Contents of ocall.cl                                          *
// *    Part 1: Restruction Binding                                 *
// *    Part 2: Generic c_type & c_code                             *
// *    Part 3: specialized c_code                                  *
// *    Part 4: Method optimizing                                   *
// *    Part 5: inline methods                                      *
// ******************************************************************
// ******************************************************************
// * Contents of ocontrol.cl                                        *
// *     Part 1: Basic Instructions                                 *
// *     Part 2: other control structures                           *
// *     Part 3: If, Case, Do, Let                                  *
// *     Part 4: Loops                                              *
// *     Part 5: Iterate                                            *
// ******************************************************************
// ******************************************************************
// *  Contents of define.cl                                         *
// *     Part 1: Set, List and Tuple creation                       *
// *     Part 2: Object definition                                  *
// *     Part 3: Method instantiation                               *
// *     Part 4: Inverse Management                                 *
// ******************************************************************

/****************/
/**  Generate  **/
/****************/


gsystem.cl contains the toplevel methods that tell how to compile a file or a module.

gexp.cl contains the definition of the "expression" method, which produces an expression
of the target language from a CLAIRE optimized expression x that must satisfy 
c_func(x) = true

gstat.cl contains the definition of the "statement" method which produces a statement
         from the external target language from a CLAIRE optimized instruction.

cgen.cl contains the definition of the C++ code producer, which encapsulate all that is
        truly specific to C++. This separation allows for the definition of alternate
        producers, such as Java.

copt.cl contains even more specific inline optimization (fragments of C++ code that
        speed up key methods & control structures)

jgen.cl contains the java code generation file (Bouygues e-Lab)

// *********************************************************************
// * Contents of gsystem.cl                                            *
// *          Part 1: Global_variables & producer interface            *
// *          Part 2: Module Compiler Interface                        *
// *          Part 3: File Compiler                                    *
// *          Part 4: Function Compiler                                *
// *********************************************************************
// *********************************************************************
// *  contents of gexp.cl                                              *
// *  Part 1: c_func & expression for objects                          *
// *  Part 2: expression for messages                                  *
// *  Part 3: expression for structures                                *
// *  Part 4: boolean optimization                                     *
// *********************************************************************
// *********************************************************************
// *  contents of gstat.cl:                                            *
// *          Part 1: Unfolding of complex expressions                 *
// *          Part 2: Basic control structures                         *
// *          Part 3: iteration                                        *
// *          Part 4: CLAIRE-specific structures                       *
// *********************************************************************
// *********************************************************************
// * Contents of cgen.cl                                               *
// *     Part 1: definition of the C++ code producer                   *
// *     Part 2: utilities for file generation                         *
// *     Part 3: interface declarations                                *
// *     Part 4: use of language dependent patterns (macros)           *
// *     Part 5: System compiling methods                              *
// *********************************************************************
// *********************************************************************
// * Contents of copt.cl                                               *
// *     Part 1: the inline coding of function calls                   *
// *     Part 2: Fast dispatch (inlining method selection)             *
// *     Part 3: Specific code for expressions                         *
// *     Part 4: Specific code for control structures                  *
// *********************************************************************
